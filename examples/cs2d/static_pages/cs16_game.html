<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>CS 1.6 2D - MVP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
font-family: 'Courier New', monospace; 
background: #1a1a1a; 
color: white; 
overflow: hidden;
user-select: none;
    }
    #game-canvas { 
cursor: crosshair; 
display: block;
image-rendering: pixelated;
    }
    
    /* 頂部資訊列 */
    #top-bar {
position: absolute;
top: 0;
left: 0;
right: 0;
height: 60px;
background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
display: flex;
justify-content: space-between;
align-items: center;
padding: 0 20px;
pointer-events: none;
    }
    
    .score {
display: flex;
gap: 20px;
font-size: 24px;
font-weight: bold;
    }
    
    .ct-score { color: #4488ff; }
    .t-score { color: #ff8844; }
    
    #round-timer {
font-size: 32px;
font-weight: bold;
color: white;
    }
    
    #round-info {
text-align: right;
font-size: 14px;
    }
    
    /* 底部資訊列 */
    #bottom-bar {
position: absolute;
bottom: 0;
left: 0;
right: 0;
height: 100px;
background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
display: flex;
justify-content: space-between;
align-items: flex-end;
padding: 20px;
pointer-events: none;
    }
    
    .health-armor {
display: flex;
flex-direction: column;
gap: 5px;
    }
    
    .bar {
width: 200px;
height: 20px;
background: rgba(0,0,0,0.5);
position: relative;
border: 1px solid #444;
    }
    
    .bar-fill {
height: 100%;
transition: width 0.3s;
    }
    
    .health-fill { background: linear-gradient(to right, #ff4444, #ff6666); }
    .armor-fill { background: linear-gradient(to right, #4444ff, #6666ff); }
    
    .bar-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 12px;
font-weight: bold;
    }
    
    #money {
font-size: 28px;
color: #44ff44;
font-weight: bold;
    }
    
    #ammo {
text-align: right;
    }
    
    #ammo-display {
font-size: 32px;
font-weight: bold;
    }
    
    #weapon-name {
font-size: 14px;
color: #aaa;
margin-top: 5px;
    }
    
    /* 控制提示 */
    #controls {
position: absolute;
top: 70px;
left: 20px;
background: rgba(0,0,0,0.8);
padding: 15px;
border-radius: 5px;
font-size: 12px;
border: 1px solid #444;
    }
    
    #controls h3 {
color: #ffaa00;
margin-bottom: 10px;
    }
    
    /* 購買選單 */
    #buy-menu {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0,0,0,0.95);
border: 2px solid #666;
border-radius: 10px;
padding: 20px;
display: none;
min-width: 500px;
max-height: 80vh;
overflow-y: auto;
    }
    
    #buy-menu h2 {
color: #ffaa00;
text-align: center;
margin-bottom: 20px;
    }
    
    .buy-tabs {
display: flex;
justify-content: center;
margin-bottom: 20px;
border-bottom: 1px solid #444;
    }
    
    .buy-tab {
padding: 10px 20px;
background: transparent;
border: none;
color: #888;
cursor: pointer;
font-size: 14px;
border-bottom: 2px solid transparent;
transition: all 0.2s;
    }
    
    .buy-tab.active {
color: #ffaa00;
border-bottom-color: #ffaa00;
    }
    
    .buy-tab:hover {
color: #fff;
    }
    
    .buy-category {
margin-bottom: 15px;
display: none;
    }
    
    .buy-category.active {
display: block;
    }
    
    .buy-category h3 {
color: #888;
font-size: 12px;
margin-bottom: 5px;
    }
    
    .buy-item {
display: flex;
justify-content: space-between;
align-items: center;
width: 100%;
padding: 12px;
margin-bottom: 8px;
background: rgba(255,255,255,0.1);
border: 1px solid #444;
color: white;
cursor: pointer;
text-align: left;
transition: all 0.2s;
border-radius: 4px;
    }
    
    .buy-item:hover {
background: rgba(255,255,255,0.2);
border-color: #ffaa00;
transform: translateX(5px);
    }
    
    .buy-item.disabled {
opacity: 0.5;
cursor: not-allowed;
transform: none;
    }
    
    .buy-item.disabled:hover {
background: rgba(255,255,255,0.1);
border-color: #444;
transform: none;
    }
    
    .weapon-info {
display: flex;
flex-direction: column;
    }
    
    .weapon-name {
font-weight: bold;
font-size: 14px;
    }
    
    .weapon-desc {
font-size: 11px;
color: #aaa;
margin-top: 2px;
    }
    
    .weapon-price {
font-weight: bold;
color: #44ff44;
font-size: 16px;
    }
    
    .buy-item.insufficient .weapon-price {
color: #ff4444;
    }
    
    .buy-shortcuts {
margin-top: 15px;
padding-top: 15px;
border-top: 1px solid #444;
text-align: center;
color: #666;
font-size: 12px;
    }
    
    .money-display {
text-align: center;
margin-bottom: 15px;
padding: 10px;
background: rgba(0,0,0,0.3);
border-radius: 5px;
    }
    
    .money-amount {
font-size: 24px;
color: #44ff44;
font-weight: bold;
    }
    
    .rebuy-section {
margin-bottom: 15px;
padding-bottom: 15px;
border-bottom: 1px solid #444;
    }
    
    .rebuy-btn {
width: 100%;
padding: 10px;
background: rgba(0,255,0,0.2);
border: 1px solid #00ff00;
color: #00ff00;
cursor: pointer;
border-radius: 4px;
font-weight: bold;
transition: all 0.2s;
    }
    
    .rebuy-btn:hover {
background: rgba(0,255,0,0.3);
    }
    
    .rebuy-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
background: rgba(100,100,100,0.2);
border-color: #666;
color: #666;
    }
    
    /* 炸彈指示器 */
    #bomb-indicator {
position: absolute;
top: 100px;
left: 50%;
transform: translateX(-50%);
background: rgba(255,0,0,0.9);
color: white;
padding: 15px 25px;
border-radius: 8px;
display: none;
text-align: center;
animation: pulse 1s infinite;
border: 2px solid #ff4444;
    }
    
    @keyframes pulse {
0%, 100% { opacity: 0.8; }
50% { opacity: 1; }
    }
    
    #bomb-timer {
font-size: 36px;
font-weight: bold;
color: #ffff00;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    /* 炸彈進度條 */
    #bomb-progress {
position: absolute;
top: 200px;
left: 50%;
transform: translateX(-50%);
background: rgba(0,0,0,0.9);
color: white;
padding: 20px;
border-radius: 8px;
display: none;
text-align: center;
min-width: 300px;
border: 2px solid #666;
    }
    
    .progress-bar {
width: 250px;
height: 20px;
background: rgba(255,255,255,0.2);
border-radius: 10px;
margin: 10px auto;
position: relative;
border: 1px solid #444;
    }
    
    .progress-fill {
height: 100%;
border-radius: 10px;
transition: width 0.1s linear;
position: relative;
    }
    
    .plant-fill {
background: linear-gradient(to right, #ff6600, #ff9900);
box-shadow: 0 0 10px rgba(255,102,0,0.5);
    }
    
    .defuse-fill {
background: linear-gradient(to right, #0066ff, #0099ff);
box-shadow: 0 0 10px rgba(0,102,255,0.5);
    }
    
    .progress-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 12px;
font-weight: bold;
text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
pointer-events: none;
    }
    
    /* 死亡畫面 */
    #death-screen {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0,0,0,0.8);
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
    }
    
    #death-message {
text-align: center;
color: #ff4444;
font-size: 48px;
font-weight: bold;
margin-bottom: 30px;
    }
    
    /* 觀戰模式 UI */
    #spectator-ui {
position: absolute;
bottom: 120px;
left: 50%;
transform: translateX(-50%);
background: rgba(0,0,0,0.8);
color: white;
padding: 15px 25px;
border-radius: 8px;
display: none;
text-align: center;
border: 1px solid #666;
    }
    
    #spectator-info {
font-size: 16px;
margin-bottom: 10px;
    }
    
    #spectator-controls {
font-size: 12px;
color: #aaa;
    }
    
    .spectator-target {
color: #ffaa00;
font-weight: bold;
    }
    
    .notification {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0,0,0,0.9);
color: #ffaa00;
padding: 20px 40px;
border-radius: 5px;
font-size: 20px;
font-weight: bold;
z-index: 10000;
animation: fadeOut 2s forwards;
    }
    
    @keyframes fadeOut {
0%, 70% { opacity: 1; }
100% { opacity: 0; }
    }
    
    /* Kill Feed UI */
    #kill-feed {
      position: absolute;
      top: 80px;
      right: 20px;
      width: 300px;
      max-height: 300px;
      overflow: hidden;
      z-index: 1000;
    }
    
    .kill-entry {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      margin-bottom: 4px;
      border-radius: 4px;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      animation: slideInKill 0.3s ease-out;
    }
    
    .kill-entry.critical {
      border-left: 3px solid #ff4444;
    }
    
    .kill-weapon {
      color: #ffaa00;
      margin: 0 8px;
      font-weight: bold;
    }
    
    .kill-victim {
      color: #ff8844;
    }
    
    .kill-killer {
      color: #4488ff;
    }
    
    @keyframes slideInKill {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    /* Team Scoreboard */
    #scoreboard {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 20px;
      min-width: 600px;
      color: white;
      z-index: 2000;
      display: none;
    }
    
    .scoreboard-header {
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 20px;
      color: #ffaa00;
    }
    
    .scoreboard-teams {
      display: flex;
      gap: 40px;
    }
    
    .scoreboard-team {
      flex: 1;
    }
    
    .team-header {
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
    }
    
    .ct-team .team-header {
      background: #4488ff;
    }
    
    .t-team .team-header {
      background: #ff8844;
    }
    
    .scoreboard-player {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #333;
    }
    
    .player-stats {
      display: flex;
      gap: 15px;
    }
    
    /* End of Round Summary */
    #round-summary {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 2px solid #ffaa00;
      border-radius: 15px;
      padding: 30px;
      min-width: 500px;
      color: white;
      z-index: 3000;
      display: none;
      text-align: center;
    }
    
    .round-summary-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 20px;
      color: #ffaa00;
    }
    
    .round-summary-stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
    }
    
    .summary-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .stat-number {
      font-size: 32px;
      font-weight: bold;
      color: #4488ff;
    }
    
    .stat-label {
      font-size: 14px;
      color: #aaa;
    }
    
    .round-summary-money {
      margin: 20px 0;
      font-size: 18px;
    }
    
    .money-gain {
      color: #44ff44;
    }
    
    .money-loss {
      color: #ff4444;
    }
    
    /* 武器掉落指示 */
    .weapon-drop-indicator {
position: absolute;
bottom: 150px;
left: 50%;
transform: translateX(-50%);
background: rgba(0,0,0,0.8);
color: white;
padding: 10px 20px;
border-radius: 5px;
display: none;
font-size: 14px;
border: 1px solid #666;
animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
0%, 100% { opacity: 0.7; }
50% { opacity: 1; }
    }
    
    /* 經濟系統提示 */
    .economy-notification {
position: fixed;
top: 200px;
right: 20px;
background: rgba(0,0,0,0.9);
color: #44ff44;
padding: 15px 20px;
border-radius: 5px;
font-size: 16px;
font-weight: bold;
z-index: 10000;
animation: slideIn 0.3s ease, fadeOutEcon 3s ease forwards;
border-left: 4px solid #44ff44;
    }
    
    @keyframes slideIn {
0% { transform: translateX(100%); opacity: 0; }
100% { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes fadeOutEcon {
0%, 80% { opacity: 1; }
100% { opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>
  
  <!-- UI 元素 -->
  <div id="top-bar">
    <div class="score">
<div class="ct-score">CT: <span id="ct-score-value">0</span></div>
<div>-</div>
<div class="t-score">T: <span id="t-score-value">0</span></div>
    </div>
    <div id="round-timer">1:55</div>
    <div id="round-info">
<div>Round <span id="round-number">1</span>/30</div>
<div id="round-phase" style="color: #ffaa00;">Buy Time</div>
    </div>
  </div>
  
  <div id="bottom-bar">
    <div class="health-armor">
<div class="bar">
  <div class="bar-fill health-fill" id="health-bar" style="width: 100%;"></div>
  <div class="bar-text">100 HP</div>
</div>
<div class="bar">
  <div class="bar-fill armor-fill" id="armor-bar" style="width: 0%;"></div>
  <div class="bar-text">0 Armor</div>
</div>
    </div>
    <div id="money">$800</div>
    <div id="ammo">
<div id="ammo-display">
  <span id="ammo-clip">30</span> / <span id="ammo-reserve">90</span>
</div>
<div id="weapon-name">Glock-18</div>
    </div>
  </div>
  
  <div id="controls">
    <h3>🎮 Game Controls</h3>
    <b>Mouse Controls:</b><br>
    🖱️ Move mouse - Aim<br>
    🖱️ Left click - Shoot<br>
    <br>
    <b>Keyboard:</b><br>
    Move: WASD (Shift to run)<br>
    Shoot: Space or Left Click<br>
    Reload: R<br>
    Interact: E<br>
    Buy Menu: B<br>
    Quick Buy: 1-5<br>
    <br>
    <small>💡 Tip: Press V to toggle auto-aim</small><br>
    <small>🔊 Sound effects activate on first shot</small>
  </div>
  
  <div id="buy-menu">
    <h2>Purchase Menu</h2>
    
    <div class="money-display">
<div class="money-amount" id="buy-menu-money">$800</div>
    </div>
    
    <div class="rebuy-section">
<button class="rebuy-btn" id="rebuy-btn" disabled onclick="game.rebuyLastPurchase()">
Rebuy Last Purchase (F3)
</button>
    </div>
    
    <div class="buy-tabs">
<button class="buy-tab active" data-category="pistols">Pistols</button>
<button class="buy-tab" data-category="rifles">Rifles</button>
<button class="buy-tab" data-category="equipment">Equipment</button>
    </div>
    
    <div id="pistols" class="buy-category active">
<button class="buy-item" data-weapon="deagle" data-price="650" data-type="pistol">
  <div class="weapon-info">
    <div class="weapon-name">Desert Eagle</div>
    <div class="weapon-desc">High damage pistol • 7/35</div>
  </div>
  <div class="weapon-price">$650</div>
</button>
<button class="buy-item" data-weapon="fiveseven" data-price="500" data-type="pistol">
  <div class="weapon-info">
    <div class="weapon-name">Five-Seven</div>
    <div class="weapon-desc">Accurate pistol • 20/100</div>
  </div>
  <div class="weapon-price">$500</div>
</button>
    </div>
    
    <div id="rifles" class="buy-category">
<button class="buy-item" data-weapon="ak47" data-price="2700" data-type="rifle" data-team="t">
  <div class="weapon-info">
    <div class="weapon-name">AK-47</div>
    <div class="weapon-desc">High damage rifle • 30/90 (T Only)</div>
  </div>
  <div class="weapon-price">$2700</div>
</button>
<button class="buy-item" data-weapon="m4a1" data-price="3100" data-type="rifle" data-team="ct">
  <div class="weapon-info">
    <div class="weapon-name">M4A1</div>
    <div class="weapon-desc">Accurate rifle • 30/90 (CT Only)</div>
  </div>
  <div class="weapon-price">$3100</div>
</button>
<button class="buy-item" data-weapon="awp" data-price="4750" data-type="rifle">
  <div class="weapon-info">
    <div class="weapon-name">AWP</div>
    <div class="weapon-desc">One-shot sniper • 10/30</div>
  </div>
  <div class="weapon-price">$4750</div>
</button>
<button class="buy-item" data-weapon="famas" data-price="2050" data-type="rifle" data-team="ct">
  <div class="weapon-info">
    <div class="weapon-name">FAMAS</div>
    <div class="weapon-desc">Budget rifle • 25/90 (CT Only)</div>
  </div>
  <div class="weapon-price">$2050</div>
</button>
<button class="buy-item" data-weapon="galil" data-price="1800" data-type="rifle" data-team="t">
  <div class="weapon-info">
    <div class="weapon-name">Galil</div>
    <div class="weapon-desc">Budget rifle • 35/90 (T Only)</div>
  </div>
  <div class="weapon-price">$1800</div>
</button>
    </div>
    
    <div id="equipment" class="buy-category">
<button class="buy-item" data-weapon="kevlar" data-price="650" data-type="equipment">
  <div class="weapon-info">
    <div class="weapon-name">Kevlar Vest</div>
    <div class="weapon-desc">Body armor protection</div>
  </div>
  <div class="weapon-price">$650</div>
</button>
<button class="buy-item" data-weapon="helmet" data-price="350" data-type="equipment">
  <div class="weapon-info">
    <div class="weapon-name">Helmet</div>
    <div class="weapon-desc">Head protection (requires Kevlar)</div>
  </div>
  <div class="weapon-price">$350</div>
</button>
<button class="buy-item" data-weapon="defuse" data-price="400" data-type="equipment" data-team="ct">
  <div class="weapon-info">
    <div class="weapon-name">Defuse Kit</div>
    <div class="weapon-desc">Faster bomb defusal (CT Only)</div>
  </div>
  <div class="weapon-price">$400</div>
</button>
<button class="buy-item" data-weapon="he" data-price="300" data-type="equipment">
  <div class="weapon-info">
    <div class="weapon-name">HE Grenade</div>
    <div class="weapon-desc">High explosive grenade</div>
  </div>
  <div class="weapon-price">$300</div>
</button>
<button class="buy-item" data-weapon="flash" data-price="200" data-type="equipment">
  <div class="weapon-info">
    <div class="weapon-name">Flashbang</div>
    <div class="weapon-desc">Blinds enemies</div>
  </div>
  <div class="weapon-price">$200</div>
</button>
<button class="buy-item" data-weapon="smoke" data-price="300" data-type="equipment">
  <div class="weapon-info">
    <div class="weapon-name">Smoke Grenade</div>
    <div class="weapon-desc">Blocks vision</div>
  </div>
  <div class="weapon-price">$300</div>
</button>
    </div>
    
    <div class="buy-shortcuts">
Press B to close • F1-F5 for quick buy • F3 to rebuy
    </div>
  </div>
  
  <div id="bomb-indicator" style="display: none;">
    <div>💣 炸彈已安裝</div>
    <div id="bomb-timer">0:45</div>
  </div>
  
  <div id="bomb-progress">
    <div id="bomb-action-text">Planting bomb...</div>
    <div class="progress-bar">
      <div class="progress-fill" id="bomb-progress-fill"></div>
      <div class="progress-text" id="bomb-progress-text">0%</div>
    </div>
  </div>
  
  <div id="death-screen">
    <div id="death-message">
<div>YOU DIED</div>
<div style="font-size: 20px; margin-top: 10px;">觀戰中...</div>
    </div>
  </div>
  
  <div class="weapon-drop-indicator" id="weapon-drop-indicator">
    Press E to pick up weapon
  </div>
  
  <div id="spectator-ui">
    <div id="spectator-info">
      Spectating: <span class="spectator-target" id="spectating-player">Free Look</span>
    </div>
    <div id="spectator-controls">
      Use 1-5 to follow players | Mouse to look around
    </div>
  </div>

  <!-- Kill Feed -->
  <div id="kill-feed"></div>

  <!-- Team Scoreboard (Toggle with Tab) -->
  <div id="scoreboard">
    <div class="scoreboard-header">Team Scoreboard</div>
    <div class="scoreboard-teams">
      <div class="scoreboard-team ct-team">
        <div class="team-header">Counter-Terrorists</div>
        <div id="ct-players"></div>
      </div>
      <div class="scoreboard-team t-team">
        <div class="team-header">Terrorists</div>
        <div id="t-players"></div>
      </div>
    </div>
  </div>

  <!-- End of Round Summary -->
  <div id="round-summary">
    <div class="round-summary-title" id="summary-title">Round Complete</div>
    <div class="round-summary-stats">
      <div class="summary-stat">
        <div class="stat-number" id="summary-kills">0</div>
        <div class="stat-label">Kills</div>
      </div>
      <div class="summary-stat">
        <div class="stat-number" id="summary-damage">0</div>
        <div class="stat-label">Damage</div>
      </div>
      <div class="summary-stat">
        <div class="stat-number" id="summary-accuracy">0%</div>
        <div class="stat-label">Accuracy</div>
      </div>
    </div>
    <div class="round-summary-money">
      <div id="summary-money-change">Money: <span class="money-gain">+$1400</span></div>
    </div>
  </div>
  
  <script>
    // CS 1.6 2D MVP 遊戲
    class CS16Game {
constructor() {
  this.canvas = document.getElementById('game-canvas');
  this.ctx = this.canvas.getContext('2d');
  this.setupCanvas();
  
  // 遊戲狀態
  this.gameState = {
    phase: 'freeze', // freeze, buy, playing, ended
    roundTime: 115,
    phaseTimer: 5, // countdown for current phase
    ctScore: 0,
    tScore: 0,
    roundNumber: 1,
    maxRounds: 30,
    bombPlanted: false,
    bombTimer: 45,
    bombSite: null,
    players: {},
    bullets: [],
    map: null,
    // Bomb system state
    bombAction: null, // 'planting' or 'defusing'
    bombProgress: 0,
    bombActionStartTime: 0,
    // Spectator system
    spectatorMode: 'free', // 'free' or 'follow'
    spectatingPlayer: null,
    spectatorCamera: { x: 800, y: 450 },
    // Economy system
    economy: {
      ctConsecutiveLosses: 0,
      tConsecutiveLosses: 0,
      lastWinner: null
    },
    // Weapon drops on ground
    weaponDrops: [],
    // Purchase history for rebuy
    purchaseHistory: [],
    // UI System
    killFeed: [],
    scoreboardVisible: false,
    roundStats: {
      kills: 0,
      damage: 0,
      shotsHit: 0,
      shotsFired: 0
    },
    // Enhanced Camera System
    camera: {
      x: 800,
      y: 450,
      targetX: 800,
      targetY: 450,
      smoothing: 0.1,
      deathCameraActive: false,
      deathCameraTarget: null,
      deathCameraStartTime: 0
    }
  };
  
  // 本地玩家
  const teamChoice = Math.random() > 0.5 ? 'ct' : 't';
  // Spawn point will be set after map is initialized
  
  this.localPlayer = {
    id: 'player-' + Math.random().toString(36).substr(2, 9),
    name: 'Player',
    team: teamChoice,
    x: 800,  // Will be updated after map loads
    y: 450,  // Will be updated after map loads
    angle: 0,
    health: 100,
    armor: 0,
    money: 800,
    maxMoney: 16000,
    alive: true,
    frozen: true, // Players start frozen in freeze time
    hasDefuseKit: false,
    hasHelmet: false,
    weapons: {
      primary: null,
      secondary: teamChoice === 'ct' ? 
        { name: 'USP-S', damage: 34, firerate: 150, ammo: { clip: 12, reserve: 100 }, type: 'pistol' } :
        { name: 'Glock-18', damage: 28, firerate: 150, ammo: { clip: 20, reserve: 120 }, type: 'pistol' }
    },
    currentWeapon: 'secondary', // 'primary' or 'secondary'
    kills: 0,
    mvps: 0
  };
  
  console.log(`Player spawned at (${spawnX}, ${spawnY}) on team ${teamChoice.toUpperCase()}`);
  
  // Economy constants
  this.ECONOMY = {
    STARTING_MONEY: 800,
    MAX_MONEY: 16000,
    ROUND_WIN_REWARD: 3250,
    ROUND_LOSS_BASE: 1400,
    ROUND_LOSS_INCREMENT: 500,
    ROUND_LOSS_MAX: 3400,
    BOMB_PLANT_REWARD: 800,
    BOMB_DEFUSE_REWARD: 3500,
    KILL_REWARDS: {
      knife: 1500,
      pistol: 300,
      rifle: 300,
      awp: 100,
      smg: 600
    },
    WEAPONS: {
      // Pistols
      'usp': { 
        price: 0, name: 'USP-S', 
        damage: { close: 34, medium: 28, far: 22 },
        firerate: 150, 
        ammo: { clip: 12, reserve: 100 }, 
        type: 'pistol',
        penetration: 0.5,
        accuracy: { standing: 0.85, moving: 0.65, firstShot: 0.95 },
        recoil: { 
          pattern: [0, -2, 1, -1, 2, -3, -1, 3], 
          recovery: 0.7,
          maxSpread: 4
        },
        switchTime: 0.4,
        model: 'usp'
      },
      'glock': { 
        price: 0, name: 'Glock-18', 
        damage: { close: 28, medium: 23, far: 18 },
        firerate: 150, 
        ammo: { clip: 20, reserve: 120 }, 
        type: 'pistol',
        penetration: 0.4,
        accuracy: { standing: 0.75, moving: 0.55, firstShot: 0.90 },
        recoil: { 
          pattern: [0, -1, 1, -2, 2, -1, 1, -2, 3, -2], 
          recovery: 0.6,
          maxSpread: 5
        },
        switchTime: 0.4,
        model: 'glock'
      },
      'deagle': { 
        price: 650, name: 'Desert Eagle', 
        damage: { close: 48, medium: 42, far: 35 },
        firerate: 225, 
        ammo: { clip: 7, reserve: 35 }, 
        type: 'pistol',
        penetration: 1.2,
        accuracy: { standing: 0.75, moving: 0.45, firstShot: 0.85 },
        recoil: { 
          pattern: [0, -8, 3, -6, 5, -4, 2], 
          recovery: 0.4,
          maxSpread: 8
        },
        switchTime: 0.5,
        model: 'deagle'
      },
      'fiveseven': { 
        price: 500, name: 'Five-Seven', 
        damage: { close: 32, medium: 27, far: 21 },
        firerate: 120, 
        ammo: { clip: 20, reserve: 100 }, 
        type: 'pistol',
        penetration: 0.8,
        accuracy: { standing: 0.80, moving: 0.60, firstShot: 0.92 },
        recoil: { 
          pattern: [0, -2, 1, -3, 2, -2, 1, -1, 3, -2], 
          recovery: 0.65,
          maxSpread: 5
        },
        switchTime: 0.4,
        model: 'fiveseven'
      },
      
      // Rifles
      'ak47': { 
        price: 2700, name: 'AK-47', 
        damage: { close: 36, medium: 32, far: 26 },
        firerate: 100, 
        ammo: { clip: 30, reserve: 90 }, 
        type: 'rifle', team: 't',
        penetration: 2.0,
        accuracy: { standing: 0.70, moving: 0.35, firstShot: 0.80 },
        recoil: { 
          pattern: [0, -4, 2, -6, 4, -8, 6, -7, 5, -9, 8, -6, 4, -10, 9, -8, 7, -5, 3, -7, 6, -4, 2, -6, 5, -3, 1, -4, 3, -2], 
          recovery: 0.3,
          maxSpread: 12
        },
        switchTime: 0.8,
        model: 'ak47'
      },
      'm4a1': { 
        price: 3100, name: 'M4A1', 
        damage: { close: 33, medium: 30, far: 25 },
        firerate: 90, 
        ammo: { clip: 30, reserve: 90 }, 
        type: 'rifle', team: 'ct',
        penetration: 1.8,
        accuracy: { standing: 0.75, moving: 0.40, firstShot: 0.85 },
        recoil: { 
          pattern: [0, -3, 1, -5, 3, -6, 4, -5, 3, -7, 5, -4, 2, -6, 4, -5, 3, -3, 1, -4, 2, -3, 1, -2, 1, -1, 0, -2, 1, 0], 
          recovery: 0.4,
          maxSpread: 9
        },
        switchTime: 0.7,
        model: 'm4a1'
      },
      'awp': { 
        price: 4750, name: 'AWP', 
        damage: { close: 115, medium: 115, far: 115 },
        firerate: 1450, 
        ammo: { clip: 10, reserve: 30 }, 
        type: 'rifle',
        penetration: 3.0,
        accuracy: { standing: 0.95, moving: 0.20, firstShot: 0.99 },
        recoil: { 
          pattern: [0, -15], 
          recovery: 0.2,
          maxSpread: 15
        },
        switchTime: 1.2,
        model: 'awp',
        screenShake: 8
      },
      'famas': { 
        price: 2050, name: 'FAMAS', 
        damage: { close: 30, medium: 26, far: 21 },
        firerate: 90, 
        ammo: { clip: 25, reserve: 90 }, 
        type: 'rifle', team: 'ct',
        penetration: 1.4,
        accuracy: { standing: 0.72, moving: 0.38, firstShot: 0.82 },
        recoil: { 
          pattern: [0, -3, 1, -4, 2, -5, 3, -4, 2, -6, 4, -3, 1, -5, 3, -4, 2, -2, 1, -3, 2, -1, 0, -2, 1], 
          recovery: 0.45,
          maxSpread: 8
        },
        switchTime: 0.6,
        model: 'famas'
      },
      'galil': { 
        price: 1800, name: 'Galil', 
        damage: { close: 30, medium: 26, far: 20 },
        firerate: 90, 
        ammo: { clip: 35, reserve: 90 }, 
        type: 'rifle', team: 't',
        penetration: 1.3,
        accuracy: { standing: 0.68, moving: 0.35, firstShot: 0.78 },
        recoil: { 
          pattern: [0, -3, 1, -5, 3, -6, 4, -5, 3, -7, 5, -4, 2, -6, 4, -5, 3, -3, 1, -4, 2, -3, 1, -2, 1, -1, 0, -2, 1, 0, -1, 1, -2, 2, -1], 
          recovery: 0.35,
          maxSpread: 10
        },
        switchTime: 0.65,
        model: 'galil'
      },
      
      // Equipment
      'kevlar': { price: 650, name: 'Kevlar Vest', type: 'equipment' },
      'helmet': { price: 350, name: 'Helmet', type: 'equipment' },
      'defuse': { price: 400, name: 'Defuse Kit', type: 'equipment', team: 'ct' },
      'he': { price: 300, name: 'HE Grenade', type: 'equipment' },
      'flash': { price: 200, name: 'Flashbang', type: 'equipment' },
      'smoke': { price: 300, name: 'Smoke Grenade', type: 'equipment' }
    }
  };

  // Material penetration properties
  this.MATERIALS = {
    WOOD: { penetrationResistance: 0.3, damageReduction: 0.15 },
    METAL: { penetrationResistance: 0.8, damageReduction: 0.35 },
    CONCRETE: { penetrationResistance: 1.2, damageReduction: 0.50 },
    THIN_WALL: { penetrationResistance: 0.2, damageReduction: 0.10 },
    THICK_WALL: { penetrationResistance: 1.5, damageReduction: 0.60 }
  };

  // Weapon system enhancements
  this.weaponSystem = {
    currentRecoil: { x: 0, y: 0 },
    recoilStep: 0,
    lastShotTime: 0,
    isMoving: false,
    switchingWeapon: false,
    switchStartTime: 0,
    lastWeapon: null,
    bulletCount: 0,
    muzzleFlash: { active: false, startTime: 0, duration: 50 },
    screenShake: { x: 0, y: 0, intensity: 0, decay: 0.9 }
  };
  
  // 輸入
  this.keys = {};
  this.mouseX = 0;
  this.mouseY = 0;
  this.aimAngle = 0;
  this.autoAim = false;  // 預設關閉，不會自動瞄準
  this.lastShootTime = 0;
  this.lastTickSecond = -1; // For bomb tick sound
  
  // Audio system
  this.initAudio();
  
  // 敵人 (單機模式)
  this.enemies = [];
  this.spawnEnemies();
  
  this.setupInput();
  this.setupMap();
  
  // Set proper spawn position after map is initialized
  const spawnPoint = this.getRandomSpawnPoint(this.localPlayer.team);
  this.localPlayer.x = spawnPoint.x;
  this.localPlayer.y = spawnPoint.y;
  
  this.setupBuyMenu();
  
  // Initialize UI
  this.updateMoneyDisplay();
  this.updateAmmoDisplay();
  this.updateHealthArmor();
  
  this.gameLoop();
  
  // 5秒後隱藏控制提示
  setTimeout(() => {
    document.getElementById('controls').style.opacity = '0.3';
  }, 5000);
  
  // 開始遊戲循環
  this.startRound();
}

setupCanvas() {
  this.canvas.width = window.innerWidth;
  this.canvas.height = window.innerHeight;
  window.addEventListener('resize', () => {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  });
}

initAudio() {
  this.audioEnabled = false;
  this.audioContext = null;
  this.sounds = {
    weapons: {
      ak47: [],
      m4a1: [],
      awp: [],
      glock: [],
      usp: [],
      deagle: []
    },
    actions: {
      reload: [],
      empty: [],
      footsteps: {
        concrete: [],
        metal: [],
        wood: [],
        water: []
      },
      voice: {
        fireInHole: null,
        bombPlanted: null,
        bombDefused: null,
        enemySpotted: null
      }
    },
    ambient: {
      wind: null,
      background: null
    }
  };
  
  // Initialize 3D audio context
  this.setupPositionalAudio();
  
  // Create weapon sound pools for overlapping sounds
  this.initializeWeaponSounds();
  
  // Initialize footstep sounds
  this.initializeFootstepSounds();
  
  // Initialize voice lines
  this.initializeVoiceLines();
  
  // Track last footstep time for sound timing
  this.lastFootstepTime = 0;
  this.footstepInterval = 400; // ms between footsteps
}

setupPositionalAudio() {
  // Setup 3D audio context for positional audio
  this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
  this.listener = this.audioContext.listener;
  
  // Set up listener orientation (facing forward)
  if (this.listener.forwardX) {
    this.listener.forwardX.setValueAtTime(0, this.audioContext.currentTime);
    this.listener.forwardY.setValueAtTime(0, this.audioContext.currentTime);
    this.listener.forwardZ.setValueAtTime(-1, this.audioContext.currentTime);
    this.listener.upX.setValueAtTime(0, this.audioContext.currentTime);
    this.listener.upY.setValueAtTime(1, this.audioContext.currentTime);
    this.listener.upZ.setValueAtTime(0, this.audioContext.currentTime);
  }
}

initializeWeaponSounds() {
  const weaponTypes = ['ak47', 'm4a1', 'awp', 'glock', 'usp', 'deagle'];
  
  weaponTypes.forEach(weapon => {
    for (let i = 0; i < 3; i++) { // 3 instances per weapon for overlapping sounds
      this.sounds.weapons[weapon].push(this.createWeaponSound(weapon));
    }
  });
}

initializeFootstepSounds() {
  const surfaces = ['concrete', 'metal', 'wood', 'water'];
  
  surfaces.forEach(surface => {
    for (let i = 0; i < 2; i++) { // 2 instances per surface
      this.sounds.actions.footsteps[surface].push(this.createFootstepSound(surface));
    }
  });
}

initializeVoiceLines() {
  this.sounds.actions.voice.fireInHole = this.createVoiceLine('fireInHole');
  this.sounds.actions.voice.bombPlanted = this.createVoiceLine('bombPlanted');
  this.sounds.actions.voice.bombDefused = this.createVoiceLine('bombDefused');
  this.sounds.actions.voice.enemySpotted = this.createVoiceLine('enemySpotted');
}

createWeaponSound(weaponType) {
  const audio = new Audio();
  
  // Generate weapon-specific sound using Web Audio API
  const buffer = this.generateWeaponSound(weaponType);
  const blob = this.bufferToWave(buffer);
  audio.src = URL.createObjectURL(blob);
  
  // Set weapon-specific volume levels
  const volumes = {
    ak47: 0.4,
    m4a1: 0.35,
    awp: 0.6,
    glock: 0.25,
    usp: 0.2,
    deagle: 0.45
  };
  
  audio.volume = volumes[weaponType] || 0.3;
  return audio;
}

createFootstepSound(surface) {
  const audio = new Audio();
  
  // Generate surface-specific footstep sound
  const buffer = this.generateFootstepSound(surface);
  const blob = this.bufferToWave(buffer);
  audio.src = URL.createObjectURL(blob);
  
  // Set surface-specific volume levels
  const volumes = {
    concrete: 0.3,
    metal: 0.4,
    wood: 0.35,
    water: 0.25
  };
  
  audio.volume = volumes[surface] || 0.3;
  return audio;
}

createVoiceLine(voiceType) {
  const audio = new Audio();
  
  // Generate voice line sound (synthesized beeps/tones representing speech)
  const buffer = this.generateVoiceLineSound(voiceType);
  const blob = this.bufferToWave(buffer);
  audio.src = URL.createObjectURL(blob);
  audio.volume = 0.6;
  
  return audio;
}

enableAudio() {
  if (this.audioEnabled) return;
  this.audioEnabled = true;
  
  // Load real sounds after user interaction
  this.loadRealSounds();
  console.log('Audio enabled - sound effects activated');
  this.showNotification('🔊 Sound effects activated!');
}

loadRealSounds() {
  // Try to load free sound effects from online sources
  // These are example URLs - replace with actual free sound effect URLs
  
  // Example: Using freesound.org or other free sources
  // Note: These are placeholder URLs - you need to get actual sound file URLs
  const soundUrls = {
    pistol: 'https://www.soundjay.com/misc/bell-ringing-05.wav',
    reload: 'https://www.soundjay.com/misc/bell-ringing-04.wav',
    empty: 'https://www.soundjay.com/misc/bell-ringing-01.wav'
  };
  
  // For now, we'll use generated sounds
  this.createGeneratedSounds();
}

createGeneratedSounds() {
  // Initialize weapon sounds with generated audio
  Object.keys(this.sounds.weapons).forEach(weaponType => {
    this.sounds.weapons[weaponType].forEach(audio => {
      const buffer = this.generateWeaponSound(weaponType);
      const blob = this.bufferToWave(buffer);
      audio.src = URL.createObjectURL(blob);
    });
  });
  
  // Initialize reload sounds
  for (let i = 0; i < 2; i++) {
    const audio = new Audio();
    const buffer = this.generateReloadSound();
    const blob = this.bufferToWave(buffer);
    audio.src = URL.createObjectURL(blob);
    audio.volume = 0.4;
    this.sounds.actions.reload.push(audio);
  }
  
  // Initialize empty clip sounds
  for (let i = 0; i < 2; i++) {
    const audio = new Audio();
    const buffer = this.generateEmptySound();
    const blob = this.bufferToWave(buffer);
    audio.src = URL.createObjectURL(blob);
    audio.volume = 0.3;
    this.sounds.actions.empty.push(audio);
  }
  
  // Old compatibility - remove the old shoot sound generation
  if (this.sounds.shoot && this.sounds.shoot.length > 0) {
    this.sounds.shoot.forEach(audio => {
    const duration = 0.15;  // Slightly longer for more realistic sound
    const sampleRate = audioContext.sampleRate;
    const numSamples = duration * sampleRate;
    
    // Create buffer
    const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
    const data = buffer.getChannelData(0);
    
    // Generate complex gunshot sound
    for (let i = 0; i < numSamples; i++) {
      let sample = 0;
      
      // Initial bang (0-10ms)
      if (i < numSamples * 0.01) {
        // Sharp attack with mixed frequencies
        const attack = 1 - (i / (numSamples * 0.01));
        sample += (Math.random() * 2 - 1) * attack;
        sample += Math.sin(2 * Math.PI * 200 * i / sampleRate) * attack * 0.5;
        sample += Math.sin(2 * Math.PI * 400 * i / sampleRate) * attack * 0.3;
      }
      
      // Main blast (10-50ms)
      else if (i < numSamples * 0.05) {
        const blastEnv = Math.exp(-(i - numSamples * 0.01) / (numSamples * 0.02));
        sample += (Math.random() * 2 - 1) * blastEnv * 0.8;
        // Add some bass frequencies
        sample += Math.sin(2 * Math.PI * 80 * i / sampleRate) * blastEnv * 0.4;
        sample += Math.sin(2 * Math.PI * 120 * i / sampleRate) * blastEnv * 0.3;
      }
      
      // Tail/echo (50ms+)
      else {
        const tailEnv = Math.exp(-(i - numSamples * 0.05) / (numSamples * 0.3));
        sample += (Math.random() * 2 - 1) * tailEnv * 0.2;
      }
      
      // Clamp and apply master envelope
      const masterEnv = i < numSamples * 0.005 ? i / (numSamples * 0.005) : 1;
      data[i] = Math.max(-1, Math.min(1, sample * masterEnv));
    }
    
    // Convert to audio element
    const blob = this.bufferToWave(buffer);
    audio.src = URL.createObjectURL(blob);
    audio.volume = 0.25;  // Adjust volume
  });
  
  // Generate reload sound (mechanical click)
  const reloadDuration = 0.3;
  const reloadSamples = reloadDuration * audioContext.sampleRate;
  const reloadBuffer = audioContext.createBuffer(1, reloadSamples, audioContext.sampleRate);
  const reloadData = reloadBuffer.getChannelData(0);
  
  for (let i = 0; i < reloadSamples; i++) {
    let sample = 0;
    
    // Click sound at start
    if (i < reloadSamples * 0.02) {
      sample += Math.sin(2 * Math.PI * 800 * i / audioContext.sampleRate) * (1 - i / (reloadSamples * 0.02));
    }
    // Mechanical sound in middle
    if (i > reloadSamples * 0.1 && i < reloadSamples * 0.15) {
      sample += Math.sin(2 * Math.PI * 400 * i / audioContext.sampleRate) * 0.3;
      sample += (Math.random() * 2 - 1) * 0.1;
    }
    // Click at end
    if (i > reloadSamples * 0.28 && i < reloadSamples * 0.3) {
      sample += Math.sin(2 * Math.PI * 600 * i / audioContext.sampleRate) * (1 - (i - reloadSamples * 0.28) / (reloadSamples * 0.02));
    }
    
    reloadData[i] = sample;
  }
  
  const reloadBlob = this.bufferToWave(reloadBuffer);
  this.sounds.reload.src = URL.createObjectURL(reloadBlob);
  this.sounds.reload.volume = 0.4;
  
  // Generate empty clip sound (click)
  const emptyDuration = 0.05;
  const emptySamples = emptyDuration * audioContext.sampleRate;
  const emptyBuffer = audioContext.createBuffer(1, emptySamples, audioContext.sampleRate);
  const emptyData = emptyBuffer.getChannelData(0);
  
  for (let i = 0; i < emptySamples; i++) {
    const env = Math.exp(-i / (emptySamples * 0.3));
    emptyData[i] = Math.sin(2 * Math.PI * 1000 * i / audioContext.sampleRate) * env * 0.5;
  }
  
  const emptyBlob = this.bufferToWave(emptyBuffer);
  this.sounds.empty.src = URL.createObjectURL(emptyBlob);
  this.sounds.empty.volume = 0.3;
}

// Enhanced sound generation functions
generateWeaponSound(weaponType) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  // Define weapon-specific characteristics
  const weaponSpecs = {
    ak47: { duration: 0.2, attack: 0.008, frequencies: [80, 200, 400], bass: 0.6, crack: 0.8 },
    m4a1: { duration: 0.15, attack: 0.005, frequencies: [120, 250, 450], bass: 0.4, crack: 0.7 },
    awp: { duration: 0.25, attack: 0.01, frequencies: [60, 150, 300], bass: 0.9, crack: 1.0 },
    glock: { duration: 0.1, attack: 0.003, frequencies: [200, 400, 800], bass: 0.2, crack: 0.5 },
    usp: { duration: 0.08, attack: 0.002, frequencies: [250, 500, 900], bass: 0.1, crack: 0.4 },
    deagle: { duration: 0.18, attack: 0.007, frequencies: [70, 180, 350], bass: 0.7, crack: 0.9 }
  };
  
  const spec = weaponSpecs[weaponType] || weaponSpecs.ak47;
  const sampleRate = audioContext.sampleRate;
  const numSamples = spec.duration * sampleRate;
  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < numSamples; i++) {
    let sample = 0;
    const t = i / sampleRate;
    const attackSamples = spec.attack * sampleRate;
    
    // Initial attack
    if (i < attackSamples) {
      const attackEnv = 1 - (i / attackSamples);
      sample += (Math.random() * 2 - 1) * attackEnv * spec.crack;
      
      // Add frequency components for character
      spec.frequencies.forEach((freq, idx) => {
        const amp = [spec.bass, 0.6, 0.3][idx] || 0.2;
        sample += Math.sin(2 * Math.PI * freq * t) * attackEnv * amp;
      });
    }
    
    // Main blast
    const blastEnv = Math.exp(-t / (spec.duration * 0.3));
    sample += (Math.random() * 2 - 1) * blastEnv * 0.5;
    
    // Add bass rumble for larger calibers
    if (spec.bass > 0.5) {
      sample += Math.sin(2 * Math.PI * 40 * t) * blastEnv * spec.bass * 0.4;
    }
    
    // Tail
    if (t > spec.duration * 0.1) {
      const tailEnv = Math.exp(-(t - spec.duration * 0.1) / (spec.duration * 0.6));
      sample += (Math.random() * 2 - 1) * tailEnv * 0.1;
    }
    
    data[i] = Math.max(-1, Math.min(1, sample));
  }
  
  return buffer;
}

generateFootstepSound(surface) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  // Define surface-specific characteristics
  const surfaceSpecs = {
    concrete: { duration: 0.15, frequencies: [100, 200, 400], noise: 0.3, resonance: 0.2 },
    metal: { duration: 0.12, frequencies: [200, 400, 800], noise: 0.2, resonance: 0.8 },
    wood: { duration: 0.18, frequencies: [80, 160, 320], noise: 0.4, resonance: 0.5 },
    water: { duration: 0.2, frequencies: [50, 100, 200], noise: 0.6, resonance: 0.3 }
  };
  
  const spec = surfaceSpecs[surface] || surfaceSpecs.concrete;
  const sampleRate = audioContext.sampleRate;
  const numSamples = spec.duration * sampleRate;
  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < numSamples; i++) {
    let sample = 0;
    const t = i / sampleRate;
    const env = Math.exp(-t / (spec.duration * 0.5));
    
    // Initial impact
    if (i < numSamples * 0.1) {
      const attackEnv = 1 - (i / (numSamples * 0.1));
      sample += (Math.random() * 2 - 1) * attackEnv * 0.8;
    }
    
    // Surface-specific frequencies
    spec.frequencies.forEach((freq, idx) => {
      const amp = [0.6, 0.4, 0.2][idx] * spec.resonance;
      sample += Math.sin(2 * Math.PI * freq * t) * env * amp;
    });
    
    // Surface noise
    sample += (Math.random() * 2 - 1) * env * spec.noise * 0.3;
    
    data[i] = Math.max(-1, Math.min(1, sample)) * 0.5;
  }
  
  return buffer;
}

generateVoiceLineSound(voiceType) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  // Define voice line patterns (simplified speech-like tones)
  const voiceSpecs = {
    fireInHole: { duration: 1.2, pattern: [200, 180, 220, 200], timing: [0.2, 0.3, 0.4, 0.3] },
    bombPlanted: { duration: 1.0, pattern: [180, 200, 160], timing: [0.3, 0.4, 0.3] },
    bombDefused: { duration: 0.8, pattern: [220, 200, 240], timing: [0.3, 0.2, 0.3] },
    enemySpotted: { duration: 1.1, pattern: [160, 180, 200, 180], timing: [0.2, 0.3, 0.3, 0.3] }
  };
  
  const spec = voiceSpecs[voiceType] || voiceSpecs.enemySpotted;
  const sampleRate = audioContext.sampleRate;
  const numSamples = spec.duration * sampleRate;
  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);
  
  let currentTime = 0;
  const totalDuration = spec.timing.reduce((a, b) => a + b, 0);
  
  for (let i = 0; i < numSamples; i++) {
    let sample = 0;
    const t = i / sampleRate;
    const progress = t / spec.duration;
    
    // Find current tone in pattern
    let segmentTime = 0;
    let toneIndex = 0;
    for (let j = 0; j < spec.timing.length; j++) {
      segmentTime += spec.timing[j];
      if (progress <= segmentTime / totalDuration) {
        toneIndex = j;
        break;
      }
    }
    
    const frequency = spec.pattern[toneIndex] || spec.pattern[0];
    const env = Math.sin(Math.PI * progress) * 0.7; // Bell envelope
    
    // Generate speech-like tone with harmonics
    sample += Math.sin(2 * Math.PI * frequency * t) * env;
    sample += Math.sin(2 * Math.PI * frequency * 2 * t) * env * 0.3;
    sample += Math.sin(2 * Math.PI * frequency * 3 * t) * env * 0.1;
    
    // Add slight roughness for voice character
    sample += (Math.random() * 2 - 1) * env * 0.1;
    
    data[i] = Math.max(-1, Math.min(1, sample)) * 0.4;
  }
  
  return buffer;
}

generateReloadSound() {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const duration = 0.3;
  const sampleRate = audioContext.sampleRate;
  const numSamples = duration * sampleRate;
  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < numSamples; i++) {
    let sample = 0;
    const t = i / sampleRate;
    
    // Click sound at start
    if (i < numSamples * 0.02) {
      sample += Math.sin(2 * Math.PI * 800 * t) * (1 - i / (numSamples * 0.02));
    }
    // Mechanical sound in middle
    if (i > numSamples * 0.1 && i < numSamples * 0.15) {
      sample += Math.sin(2 * Math.PI * 400 * t) * 0.3;
      sample += (Math.random() * 2 - 1) * 0.1;
    }
    // Click at end
    if (i > numSamples * 0.28 && i < numSamples * 0.3) {
      sample += Math.sin(2 * Math.PI * 600 * t) * (1 - (i - numSamples * 0.28) / (numSamples * 0.02));
    }
    
    data[i] = sample;
  }
  
  return buffer;
}

generateEmptySound() {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const duration = 0.05;
  const sampleRate = audioContext.sampleRate;
  const numSamples = duration * sampleRate;
  const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < numSamples; i++) {
    const env = Math.exp(-i / (numSamples * 0.3));
    data[i] = Math.sin(2 * Math.PI * 1000 * i / sampleRate) * env * 0.5;
  }
  
  return buffer;
}

bufferToWave(buffer) {
  const length = buffer.length * buffer.numberOfChannels * 2;
  const arrayBuffer = new ArrayBuffer(44 + length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let offset = 0;
  let pos = 0;
  
  // Write WAV header
  const setUint32 = (data) => {
    view.setUint32(pos, data, true);
    pos += 4;
  };
  const setUint16 = (data) => {
    view.setUint16(pos, data, true);
    pos += 2;
  };
  
  // RIFF identifier
  setUint32(0x46464952);
  // File length
  setUint32(36 + length);
  // RIFF type
  setUint32(0x45564157);
  // Format chunk identifier
  setUint32(0x20746d66);
  // Format chunk length
  setUint32(16);
  // Sample format (raw PCM)
  setUint16(1);
  // Channel count
  setUint16(buffer.numberOfChannels);
  // Sample rate
  setUint32(buffer.sampleRate);
  // Byte rate
  setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
  // Block align
  setUint16(buffer.numberOfChannels * 2);
  // Bits per sample
  setUint16(16);
  // Data chunk identifier
  setUint32(0x61746164);
  // Data chunk length
  setUint32(length);
  
  // Write PCM samples
  for (let i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  
  while (offset < buffer.length) {
    for (let i = 0; i < buffer.numberOfChannels; i++) {
      let sample = Math.max(-1, Math.min(1, channels[i][offset]));
      sample = sample * 0x7FFF;
      view.setInt16(pos, sample, true);
      pos += 2;
    }
    offset++;
  }
  
  return new Blob([arrayBuffer], { type: 'audio/wav' });
}

// Enhanced audio playback functions with 3D positional audio
playWeaponSound(weaponType, x, y) {
  if (!this.audioEnabled) return;
  
  const weaponSounds = this.sounds.weapons[weaponType];
  if (!weaponSounds) return;
  
  // Find available sound instance
  const sound = weaponSounds.find(s => s.paused || s.ended);
  if (sound) {
    sound.currentTime = 0;
    
    // Apply 3D positioning
    this.apply3DPositioning(sound, x, y);
    
    sound.play().catch(e => console.log('Weapon sound play failed:', e));
  }
}

playShootSound(weaponType = 'ak47') {
  // Use current weapon type if available
  const currentWeapon = this.getCurrentWeapon();
  if (currentWeapon && currentWeapon.type) {
    weaponType = currentWeapon.type;
  }
  
  this.playWeaponSound(weaponType, this.localPlayer.x, this.localPlayer.y);
}

playReloadSound() {
  if (!this.audioEnabled || !this.sounds.actions.reload.length) return;
  
  const sound = this.sounds.actions.reload.find(s => s.paused || s.ended);
  if (sound) {
    sound.currentTime = 0;
    this.apply3DPositioning(sound, this.localPlayer.x, this.localPlayer.y);
    sound.play().catch(e => console.log('Reload sound failed:', e));
  }
}

playEmptySound() {
  if (!this.audioEnabled || !this.sounds.actions.empty.length) return;
  
  const sound = this.sounds.actions.empty.find(s => s.paused || s.ended);
  if (sound) {
    sound.currentTime = 0;
    this.apply3DPositioning(sound, this.localPlayer.x, this.localPlayer.y);
    sound.play().catch(e => console.log('Empty sound failed:', e));
  }
}

playFootstepSound(surface = 'concrete', x, y) {
  if (!this.audioEnabled) return;
  
  const now = Date.now();
  if (now - this.lastFootstepTime < this.footstepInterval) return;
  
  const surfaceSounds = this.sounds.actions.footsteps[surface];
  if (!surfaceSounds || surfaceSounds.length === 0) return;
  
  const sound = surfaceSounds.find(s => s.paused || s.ended);
  if (sound) {
    sound.currentTime = 0;
    this.apply3DPositioning(sound, x, y);
    sound.play().catch(e => console.log('Footstep sound failed:', e));
    this.lastFootstepTime = now;
  }
}

playVoiceLine(voiceType) {
  if (!this.audioEnabled) return;
  
  const voiceSound = this.sounds.actions.voice[voiceType];
  if (voiceSound) {
    voiceSound.currentTime = 0;
    // Voice lines are global, not positional
    voiceSound.play().catch(e => console.log('Voice line failed:', e));
    
    // Show subtitle for voice line
    this.showVoiceLineSubtitle(voiceType);
  }
}

apply3DPositioning(audio, sourceX, sourceY) {
  // Calculate distance and direction from player
  const dx = sourceX - this.localPlayer.x;
  const dy = sourceY - this.localPlayer.y;
  const distance = Math.hypot(dx, dy);
  
  // Calculate volume based on distance (falloff)
  const maxDistance = 800; // Maximum hearing distance
  const minVolume = 0.05;
  let volumeMultiplier = Math.max(minVolume, 1 - (distance / maxDistance));
  
  // Apply distance-based volume
  const baseVolume = audio.volume;
  audio.volume = baseVolume * volumeMultiplier;
  
  // Calculate stereo panning (-1 = left, 1 = right)
  if (distance > 0) {
    const angle = Math.atan2(dx, dy);
    const panValue = Math.sin(angle) * Math.min(1, distance / 200);
    
    // Apply panning using Web Audio API if available
    if (this.audioContext && audio.mozSourceNode) {
      const panner = this.audioContext.createStereoPanner();
      panner.pan.setValueAtTime(panValue, this.audioContext.currentTime);
      audio.mozSourceNode.connect(panner);
      panner.connect(this.audioContext.destination);
    }
  }
}

updateListener3DPosition() {
  // Update listener position for 3D audio
  if (this.listener && this.listener.positionX) {
    this.listener.positionX.setValueAtTime(this.localPlayer.x / 100, this.audioContext.currentTime);
    this.listener.positionY.setValueAtTime(this.localPlayer.y / 100, this.audioContext.currentTime);
    this.listener.positionZ.setValueAtTime(0, this.audioContext.currentTime);
  }
}

showVoiceLineSubtitle(voiceType) {
  const subtitles = {
    fireInHole: 'Fire in the hole!',
    bombPlanted: 'Bomb has been planted!',
    bombDefused: 'Bomb has been defused!',
    enemySpotted: 'Enemy spotted!'
  };
  
  const subtitle = subtitles[voiceType];
  if (subtitle) {
    this.showNotification(subtitle, 2000);
  }
}

// Enhanced UI Management System
addKillFeedEntry(killer, victim, weapon, isCritical = false) {
  const killEntry = {
    id: Date.now() + Math.random(),
    killer: killer,
    victim: victim,
    weapon: weapon,
    isCritical: isCritical,
    timestamp: Date.now()
  };
  
  this.gameState.killFeed.unshift(killEntry);
  
  // Keep only the last 5 entries
  if (this.gameState.killFeed.length > 5) {
    this.gameState.killFeed = this.gameState.killFeed.slice(0, 5);
  }
  
  this.updateKillFeedUI();
}

updateKillFeedUI() {
  const killFeedElement = document.getElementById('kill-feed');
  if (!killFeedElement) return;
  
  killFeedElement.innerHTML = '';
  
  this.gameState.killFeed.forEach((entry, index) => {
    const entryElement = document.createElement('div');
    entryElement.className = `kill-entry ${entry.isCritical ? 'critical' : ''}`;
    
    // Add fade effect for older entries
    const age = Date.now() - entry.timestamp;
    const opacity = Math.max(0.3, 1 - (age / 8000)); // Fade over 8 seconds
    entryElement.style.opacity = opacity;
    
    entryElement.innerHTML = `
      <span class="kill-killer">${entry.killer}</span>
      <span class="kill-weapon">${entry.weapon}</span>
      <span class="kill-victim">${entry.victim}</span>
    `;
    
    killFeedElement.appendChild(entryElement);
  });
}

toggleScoreboard() {
  this.gameState.scoreboardVisible = true;
  this.showScoreboard();
}

showScoreboard() {
  const scoreboardElement = document.getElementById('scoreboard');
  if (!scoreboardElement) return;
  
  scoreboardElement.style.display = 'block';
  this.updateScoreboardContent();
}

hideScoreboard() {
  this.gameState.scoreboardVisible = false;
  const scoreboardElement = document.getElementById('scoreboard');
  if (scoreboardElement) {
    scoreboardElement.style.display = 'none';
  }
}

updateScoreboardContent() {
  const ctPlayersElement = document.getElementById('ct-players');
  const tPlayersElement = document.getElementById('t-players');
  
  if (!ctPlayersElement || !tPlayersElement) return;
  
  // Clear existing content
  ctPlayersElement.innerHTML = '';
  tPlayersElement.innerHTML = '';
  
  // Add local player
  const localPlayerElement = this.createPlayerScoreElement(this.localPlayer);
  if (this.localPlayer.team === 'ct') {
    ctPlayersElement.appendChild(localPlayerElement);
  } else {
    tPlayersElement.appendChild(localPlayerElement);
  }
  
  // Add AI enemies (simulate teammate data)
  this.enemies.forEach((enemy, index) => {
    const enemyData = {
      name: enemy.name || `Bot${index + 1}`,
      kills: enemy.kills || Math.floor(Math.random() * 3),
      deaths: enemy.deaths || Math.floor(Math.random() * 2),
      money: enemy.money || Math.floor(Math.random() * 5000 + 1000),
      alive: enemy.alive
    };
    
    const enemyElement = this.createPlayerScoreElement(enemyData);
    // For simplicity, add all enemies as opposite team
    if (this.localPlayer.team === 'ct') {
      tPlayersElement.appendChild(enemyElement);
    } else {
      ctPlayersElement.appendChild(enemyElement);
    }
  });
}

createPlayerScoreElement(player) {
  const playerElement = document.createElement('div');
  playerElement.className = 'scoreboard-player';
  
  const statusIcon = player.alive ? '●' : '☠';
  const statusColor = player.alive ? '#44ff44' : '#ff4444';
  
  playerElement.innerHTML = `
    <div>
      <span style="color: ${statusColor};">${statusIcon}</span>
      ${player.name}
    </div>
    <div class="player-stats">
      <span>${player.kills || 0}K</span>
      <span>${player.deaths || 0}D</span>
      <span>$${(player.money || 0).toLocaleString()}</span>
    </div>
  `;
  
  return playerElement;
}

showRoundSummary(roundWinner, roundReason) {
  const summaryElement = document.getElementById('round-summary');
  if (!summaryElement) return;
  
  // Update summary title
  const titleElement = document.getElementById('summary-title');
  const winMessage = roundWinner === this.localPlayer.team ? 'Victory!' : 'Defeat';
  titleElement.textContent = winMessage;
  titleElement.style.color = roundWinner === this.localPlayer.team ? '#44ff44' : '#ff4444';
  
  // Update stats
  document.getElementById('summary-kills').textContent = this.gameState.roundStats.kills;
  document.getElementById('summary-damage').textContent = Math.floor(this.gameState.roundStats.damage);
  
  const accuracy = this.gameState.roundStats.shotsFired > 0 ? 
    Math.floor((this.gameState.roundStats.shotsHit / this.gameState.roundStats.shotsFired) * 100) : 0;
  document.getElementById('summary-accuracy').textContent = accuracy + '%';
  
  // Calculate money change
  const moneyChangeElement = document.getElementById('summary-money-change');
  const moneyChange = this.calculateRoundMoneyReward(roundWinner, roundReason);
  const changeClass = moneyChange >= 0 ? 'money-gain' : 'money-loss';
  const changeSign = moneyChange >= 0 ? '+' : '';
  
  moneyChangeElement.innerHTML = `Money: <span class="${changeClass}">${changeSign}$${moneyChange}</span>`;
  
  // Show the summary
  summaryElement.style.display = 'block';
  
  // Hide after 4 seconds
  setTimeout(() => {
    summaryElement.style.display = 'none';
    this.resetRoundStats();
  }, 4000);
}

calculateRoundMoneyReward(winner, reason) {
  // This is a simplified calculation - the actual endRound function handles the real money
  if (winner === this.localPlayer.team) {
    return 3250; // Win bonus
  } else {
    // Loss bonus increases with consecutive losses
    const losses = this.gameState.economy[this.localPlayer.team + 'ConsecutiveLosses'] || 0;
    return Math.min(1400 + (losses * 500), 3400);
  }
}

resetRoundStats() {
  this.gameState.roundStats = {
    kills: 0,
    damage: 0,
    shotsHit: 0,
    shotsFired: 0
  };
}

updateRoundStats(type, value = 1) {
  switch(type) {
    case 'kill':
      this.gameState.roundStats.kills += value;
      break;
    case 'damage':
      this.gameState.roundStats.damage += value;
      break;
    case 'shot':
      this.gameState.roundStats.shotsFired += value;
      break;
    case 'hit':
      this.gameState.roundStats.shotsHit += value;
      break;
  }
}

// Enhanced Camera System
updateCameraSystem() {
  const now = Date.now();
  
  if (this.localPlayer.alive && !this.gameState.camera.deathCameraActive) {
    // Smooth camera follow for living player
    this.gameState.camera.targetX = this.localPlayer.x;
    this.gameState.camera.targetY = this.localPlayer.y;
    
    // Use faster smoothing during combat for responsiveness
    const recentlyShot = now - this.weaponSystem.lastShotTime < 1000;
    const smoothing = recentlyShot ? 0.2 : 0.1;
    this.gameState.camera.smoothing = smoothing;
    
  } else if (!this.localPlayer.alive) {
    // Death camera system
    if (!this.gameState.camera.deathCameraActive) {
      this.activateDeathCamera();
    } else {
      this.updateDeathCamera();
    }
  }
  
  // Apply smooth camera movement
  const dx = this.gameState.camera.targetX - this.gameState.camera.x;
  const dy = this.gameState.camera.targetY - this.gameState.camera.y;
  
  this.gameState.camera.x += dx * this.gameState.camera.smoothing;
  this.gameState.camera.y += dy * this.gameState.camera.smoothing;
  
  // Clamp camera to map bounds
  const margin = 200;
  this.gameState.camera.x = Math.max(margin, Math.min(1600 - margin, this.gameState.camera.x));
  this.gameState.camera.y = Math.max(margin, Math.min(900 - margin, this.gameState.camera.y));
}

activateDeathCamera() {
  this.gameState.camera.deathCameraActive = true;
  this.gameState.camera.deathCameraStartTime = Date.now();
  
  // Find the killer or closest enemy for death camera
  const killer = this.findDeathCameraTarget();
  if (killer) {
    this.gameState.camera.deathCameraTarget = killer;
    this.gameState.camera.targetX = killer.x;
    this.gameState.camera.targetY = killer.y;
    this.gameState.camera.smoothing = 0.05; // Slow dramatic movement
  }
}

findDeathCameraTarget() {
  // Find closest living enemy to focus death camera on
  const aliveEnemies = this.enemies.filter(e => e.alive);
  if (aliveEnemies.length === 0) return null;
  
  // Sort by distance from player's death location
  aliveEnemies.sort((a, b) => {
    const distA = Math.hypot(a.x - this.localPlayer.x, a.y - this.localPlayer.y);
    const distB = Math.hypot(b.x - this.localPlayer.x, b.y - this.localPlayer.y);
    return distA - distB;
  });
  
  return aliveEnemies[0];
}

updateDeathCamera() {
  const now = Date.now();
  const deathCameraAge = now - this.gameState.camera.deathCameraStartTime;
  
  // First 2 seconds: focus on killer/closest enemy
  if (deathCameraAge < 2000 && this.gameState.camera.deathCameraTarget) {
    const target = this.gameState.camera.deathCameraTarget;
    if (target.alive) {
      this.gameState.camera.targetX = target.x;
      this.gameState.camera.targetY = target.y;
      this.gameState.camera.smoothing = 0.03; // Very slow dramatic movement
    }
  } 
  // After 2 seconds: switch to spectator mode
  else if (deathCameraAge >= 2000) {
    // Transition to spectator system
    if (this.gameState.spectatorMode === 'follow' && this.gameState.spectatingPlayer) {
      const target = this.gameState.spectatingPlayer;
      this.gameState.camera.targetX = target.x;
      this.gameState.camera.targetY = target.y;
      this.gameState.camera.smoothing = 0.08;
    } else {
      // Free look mode - allow mouse control
      this.updateSpectatorCamera();
      this.gameState.camera.targetX = this.gameState.spectatorCamera.x;
      this.gameState.camera.targetY = this.gameState.spectatorCamera.y;
      this.gameState.camera.smoothing = 0.05;
    }
  }
}

resetCameraSystem() {
  this.gameState.camera.deathCameraActive = false;
  this.gameState.camera.deathCameraTarget = null;
  this.gameState.camera.smoothing = 0.1;
  
  // Set camera to player position
  this.gameState.camera.x = this.localPlayer.x;
  this.gameState.camera.y = this.localPlayer.y;
  this.gameState.camera.targetX = this.localPlayer.x;
  this.gameState.camera.targetY = this.localPlayer.y;
}

// Enhanced visual feedback system
createScreenFlash(color = 'rgba(255, 255, 255, 0.5)', duration = 200) {
  if (!this.gameState.screenFlash) {
    this.gameState.screenFlash = {};
  }
  
  this.gameState.screenFlash = {
    active: true,
    color: color,
    startTime: Date.now(),
    duration: duration
  };
}

renderScreenFlash() {
  if (!this.gameState.screenFlash || !this.gameState.screenFlash.active) return;
  
  const now = Date.now();
  const age = now - this.gameState.screenFlash.startTime;
  const progress = age / this.gameState.screenFlash.duration;
  
  if (progress >= 1) {
    this.gameState.screenFlash.active = false;
    return;
  }
  
  const alpha = (1 - progress) * 0.5;
  this.ctx.save();
  this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  this.ctx.fillStyle = this.gameState.screenFlash.color.replace(/[\d\.]+\)$/g, alpha + ')');
  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  this.ctx.restore();
}

showGameOverScreen(winner, isVictory, ctScore, tScore) {
  // Create a dramatic full-screen game over display
  const overlay = document.createElement('div');
  overlay.id = 'game-over-screen';
  overlay.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 5000;
    color: white;
    font-family: 'Courier New', monospace;
    animation: fadeInGameOver 1s ease-out;
  `;
  
  const title = document.createElement('div');
  title.style.cssText = `
    font-size: 64px;
    font-weight: bold;
    margin-bottom: 20px;
    color: ${isVictory ? '#44ff44' : '#ff4444'};
    text-shadow: 0 0 20px ${isVictory ? '#44ff44' : '#ff4444'};
  `;
  title.textContent = isVictory ? 'VICTORY!' : 'DEFEAT';
  
  const winnerText = document.createElement('div');
  winnerText.style.cssText = `
    font-size: 32px;
    margin-bottom: 30px;
    color: #ffaa00;
  `;
  winnerText.textContent = `${winner} Win!`;
  
  const scoreText = document.createElement('div');
  scoreText.style.cssText = `
    font-size: 48px;
    font-weight: bold;
    margin-bottom: 40px;
    color: white;
  `;
  scoreText.textContent = `${ctScore} - ${tScore}`;
  
  const statsContainer = document.createElement('div');
  statsContainer.style.cssText = `
    display: flex;
    gap: 60px;
    margin-bottom: 40px;
  `;
  
  // Player stats summary
  const playerStats = [
    { label: 'Kills', value: this.localPlayer.kills || 0 },
    { label: 'Total Damage', value: Math.floor(this.gameState.roundStats.damage) },
    { label: 'Money', value: `$${this.localPlayer.money.toLocaleString()}` }
  ];
  
  playerStats.forEach(stat => {
    const statDiv = document.createElement('div');
    statDiv.style.cssText = `
      text-align: center;
    `;
    statDiv.innerHTML = `
      <div style="font-size: 36px; font-weight: bold; color: #4488ff;">${stat.value}</div>
      <div style="font-size: 18px; color: #aaa;">${stat.label}</div>
    `;
    statsContainer.appendChild(statDiv);
  });
  
  const restartText = document.createElement('div');
  restartText.style.cssText = `
    font-size: 18px;
    color: #888;
    text-align: center;
  `;
  restartText.innerHTML = `
    <div>Game Over</div>
    <div style="margin-top: 10px;">Refresh the page to play again</div>
  `;
  
  // Add CSS animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes fadeInGameOver {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
  `;
  document.head.appendChild(style);
  
  overlay.appendChild(title);
  overlay.appendChild(winnerText);
  overlay.appendChild(scoreText);
  overlay.appendChild(statsContainer);
  overlay.appendChild(restartText);
  
  document.body.appendChild(overlay);
  
  // Add celebration screen flash
  if (isVictory) {
    this.createScreenFlash('rgba(68, 255, 68, 0.3)', 2000);
  } else {
    this.createScreenFlash('rgba(255, 68, 68, 0.3)', 2000);
  }
}

setupInput() {
  // Mouse tracking
  this.canvas.addEventListener('mousemove', (e) => {
    const rect = this.canvas.getBoundingClientRect();
    this.mouseX = e.clientX - rect.left;
    this.mouseY = e.clientY - rect.top;
    
    // Calculate aim angle from player to mouse
    this.updateAimAngle();
  });
  
  // Mouse click to shoot
  this.canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) { // Left click
      // Enable audio on first interaction (browser requirement)
      if (!this.audioEnabled) {
        this.enableAudio();
      }
      this.shoot();
    }
  });
  
  // Prevent right-click menu
  this.canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });
  
  // 鍵盤控制
  document.addEventListener('keydown', (e) => {
    this.keys[e.key.toLowerCase()] = true;
    
    // Debug message
    if (['w','a','s','d'].includes(e.key.toLowerCase())) {
      console.log('Key pressed:', e.key.toLowerCase(), 'Player pos:', this.localPlayer.x, this.localPlayer.y);
    }
    
    // 空白鍵射擊
    if (e.key === ' ') {
      e.preventDefault();
      // Enable audio on first interaction
      if (!this.audioEnabled) {
        this.enableAudio();
      }
      this.shoot();
    }
    
    // V to toggle auto-aim (optional)
    if (e.key === 'v') {
      this.autoAim = !this.autoAim;
      this.showNotification(this.autoAim ? 'Auto-aim: ON' : 'Auto-aim: OFF');
    }
    
    // B 購買選單
    if (e.key === 'b') {
      const menu = document.getElementById('buy-menu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
    
    // R 換彈
    if (e.key === 'r') {
      this.reload();
    }
    
    // G 鍵丟棄武器
    if (e.key === 'g') {
      this.dropCurrentWeapon();
    }
    
    // Q 鍵快速切換武器 (切換到上一個武器)
    if (e.key === 'q') {
      this.quickSwitchWeapon();
    }
    
    // E 互動 (撿武器或炸彈互動)
    if (e.key === 'e') {
      this.interact();
    }
    
    // Tab 鍵切換計分板
    if (e.key === 'Tab') {
      e.preventDefault();
      this.toggleScoreboard();
    }
    
    // F 鍵語音指令 (Fire in the hole!)
    if (e.key === 'f') {
      this.playVoiceLine('fireInHole');
    }
    
    // F3 重複購買
    if (e.key === 'F3') {
      e.preventDefault();
      this.rebuyLastPurchase();
    }
    
    // 1-2 鍵切換武器 / 觀戰切換
    if (e.key >= '1' && e.key <= '5') {
      if (this.localPlayer.alive) {
        const num = parseInt(e.key);
        if (num === 1) {
          this.switchWeapon('secondary');
        } else if (num === 2) {
          this.switchWeapon('primary');
        } else {
          // Old quick buy for numbers 3-5
          this.quickBuy(e.key);
        }
      } else {
        this.switchSpectatorTarget(parseInt(e.key));
      }
    }
  });
  
  document.addEventListener('keyup', (e) => {
    this.keys[e.key.toLowerCase()] = false;
    
    // Hide scoreboard when Tab key is released
    if (e.key === 'Tab') {
      this.hideScoreboard();
    }
    
    // Stop bomb action when E key is released
    if (e.key === 'e' && this.gameState.bombAction) {
      this.stopBombAction();
    }
  });
  
  // Buy buttons are handled in setupBuyMenu()
}

setupMap() {
  // Enhanced de_dust2 inspired map layout
  this.gameState.map = {
    width: 2000,
    height: 1200,
    // Detailed wall structure resembling de_dust2
    walls: [
      // Map boundaries
      { x: 0, y: 0, width: 2000, height: 30 },         // Top border
      { x: 0, y: 1170, width: 2000, height: 30 },      // Bottom border
      { x: 0, y: 0, width: 30, height: 1200 },         // Left border
      { x: 1970, y: 0, width: 30, height: 1200 },      // Right border
      
      // T Spawn area walls
      { x: 100, y: 950, width: 300, height: 30 },      // T spawn back wall
      { x: 100, y: 800, width: 30, height: 150 },      // T spawn left wall
      { x: 400, y: 800, width: 30, height: 150 },      // T spawn right wall
      
      // CT Spawn area walls  
      { x: 1500, y: 220, width: 300, height: 30 },     // CT spawn back wall
      { x: 1500, y: 250, width: 30, height: 150 },     // CT spawn left wall
      { x: 1800, y: 250, width: 30, height: 150 },     // CT spawn right wall
      
      // Middle area - Long A corridor
      { x: 500, y: 200, width: 30, height: 200 },      // Long A left wall
      { x: 900, y: 200, width: 30, height: 200 },      // Long A right wall
      { x: 500, y: 200, width: 400, height: 30 },      // Long A top wall
      
      // A Site structures
      { x: 200, y: 450, width: 100, height: 100 },     // A site box 1
      { x: 350, y: 500, width: 80, height: 80 },       // A site box 2
      { x: 450, y: 420, width: 120, height: 40 },      // A site platform
      
      // Catwalk/Upper tunnels
      { x: 700, y: 100, width: 30, height: 150 },      // Catwalk support
      { x: 850, y: 100, width: 30, height: 150 },      // Catwalk support
      
      // Middle area - connecting mid
      { x: 800, y: 500, width: 200, height: 30 },      // Mid divider
      { x: 900, y: 530, width: 30, height: 100 },      // Mid pillar
      { x: 800, y: 630, width: 200, height: 30 },      // Mid lower divider
      
      // B Tunnels entrance
      { x: 600, y: 800, width: 30, height: 100 },      // B tunnel left wall
      { x: 900, y: 800, width: 30, height: 100 },      // B tunnel right wall
      { x: 600, y: 800, width: 300, height: 30 },      // B tunnel top wall
      
      // B Site structures
      { x: 1200, y: 750, width: 120, height: 80 },     // B site box 1
      { x: 1400, y: 800, width: 100, height: 60 },     // B site box 2
      { x: 1350, y: 650, width: 80, height: 80 },      // B site cover
      
      // Additional tactical cover
      { x: 750, y: 350, width: 60, height: 60 },       // Mid cover
      { x: 1100, y: 400, width: 80, height: 30 },      // Rotation cover
      
      // Short A path structures
      { x: 300, y: 300, width: 150, height: 30 },      // Short A wall
      { x: 250, y: 330, width: 30, height: 100 },      // Short A corner
      { x: 280, y: 380, width: 100, height: 30 },      // Short A box
      
      // Long A doors/pit area
      { x: 530, y: 430, width: 30, height: 80 },       // Long A pit wall left
      { x: 640, y: 430, width: 30, height: 80 },       // Long A pit wall right
      { x: 560, y: 480, width: 80, height: 30 },       // Long A pit floor
      
      // Catwalk bridge
      { x: 730, y: 250, width: 100, height: 20 },      // Catwalk bridge
      { x: 720, y: 270, width: 30, height: 50 },       // Bridge support 1
      { x: 810, y: 270, width: 30, height: 50 },       // Bridge support 2
      
      // A Ramp/stairs
      { x: 400, y: 350, width: 80, height: 20 },       // A ramp top
      { x: 410, y: 370, width: 60, height: 20 },       // A ramp middle
      { x: 420, y: 390, width: 40, height: 20 },       // A ramp bottom
      
      // B Tunnels - upper tunnel
      { x: 1050, y: 700, width: 30, height: 100 },     // Upper B tunnel wall
      { x: 1080, y: 730, width: 120, height: 30 },     // Upper B tunnel roof
      { x: 1180, y: 700, width: 30, height: 100 },     // Upper B tunnel exit
      
      // B Site window/balcony
      { x: 1450, y: 680, width: 80, height: 30 },      // B balcony
      { x: 1470, y: 710, width: 30, height: 60 },      // B balcony support
      { x: 1500, y: 710, width: 30, height: 60 },      // B balcony rail
      
      // Middle area - Xbox/connector box
      { x: 950, y: 450, width: 50, height: 50 },       // Xbox equivalent
      { x: 870, y: 580, width: 40, height: 40 },       // Connector box
      { x: 1020, y: 520, width: 60, height: 30 },      // Mid connector wall
      
      // T Mid to B connector
      { x: 700, y: 900, width: 150, height: 30 },      // T mid connector wall
      { x: 750, y: 870, width: 30, height: 30 },       // Connector corner
      { x: 820, y: 870, width: 30, height: 30 },       // Connector corner 2
      
      // A Site default/quad box area
      { x: 150, y: 550, width: 60, height: 40 },       // Default box
      { x: 320, y: 570, width: 50, height: 50 },       // Quad box
      { x: 180, y: 480, width: 40, height: 30 },       // Site corner
      
      // B Site back boxes/ninja spot
      { x: 1300, y: 850, width: 40, height: 40 },      // Back site box
      { x: 1380, y: 880, width: 60, height: 30 },      // Ninja box
      { x: 1250, y: 800, width: 30, height: 40 },      // Site corner box
    ],
    
    // Strategic bomb sites
    bombSites: [
      { name: 'A', x: 350, y: 500, radius: 120, zone: 'long_a' },
      { name: 'B', x: 1300, y: 750, radius: 120, zone: 'b_site' }
    ],
    
    // Spawn points for both teams
    spawns: {
      ct: [
        { x: 1650, y: 300 }, { x: 1700, y: 320 }, { x: 1750, y: 300 },
        { x: 1650, y: 350 }, { x: 1700, y: 370 }
      ],
      t: [
        { x: 200, y: 900 }, { x: 250, y: 920 }, { x: 300, y: 900 },
        { x: 200, y: 850 }, { x: 250, y: 870 }
      ]
    },
    
    // Strategic points for AI navigation - enhanced with new map elements
    tacticalPoints: {
      chokePoints: [
        { name: 'Long A', x: 700, y: 300, importance: 0.9 },
        { name: 'Short A', x: 320, y: 350, importance: 0.8 },
        { name: 'Mid', x: 900, y: 550, importance: 0.8 },
        { name: 'Xbox Mid', x: 975, y: 475, importance: 0.7 },
        { name: 'B Tunnels', x: 750, y: 850, importance: 0.7 },
        { name: 'Upper B', x: 1115, y: 750, importance: 0.6 },
        { name: 'Catwalk', x: 780, y: 250, importance: 0.6 }
      ],
      sniperSpots: [
        { name: 'A Long', x: 800, y: 250, coverage: ['long_a', 'catwalk'] },
        { name: 'Mid AWP', x: 950, y: 580, coverage: ['mid', 'b_tunnels', 'xbox'] },
        { name: 'B Site Window', x: 1480, y: 690, coverage: ['b_site', 'upper_b'] },
        { name: 'Catwalk AWP', x: 780, y: 200, coverage: ['long_a', 'short_a'] },
        { name: 'A Pit', x: 590, y: 460, coverage: ['long_a', 'a_site'] }
      ],
      coverSpots: [
        { name: 'A Default', x: 180, y: 550, protection: 0.9 },
        { name: 'A Quad', x: 345, y: 595, protection: 0.8 },
        { name: 'A Box', x: 250, y: 500, protection: 0.8 },
        { name: 'Short A Box', x: 330, y: 380, protection: 0.7 },
        { name: 'Mid Xbox', x: 975, y: 475, protection: 0.8 },
        { name: 'Mid Connector', x: 890, y: 600, protection: 0.6 },
        { name: 'B Platform', x: 1350, y: 680, protection: 0.7 },
        { name: 'B Back Box', x: 1320, y: 870, protection: 0.6 },
        { name: 'B Ninja', x: 1410, y: 895, protection: 0.5 },
        { name: 'B Balcony', x: 1490, y: 695, protection: 0.8 }
      ]
    },
    
    // Sound propagation ranges (in pixels)
    soundRanges: {
      footsteps: 200,
      gunshots: 500,
      reload: 150,
      bomb_plant: 300,
      bomb_defuse: 200
    }
  };
  
  // Initialize minimap
  this.setupMinimap();
  
  console.log('Enhanced de_dust2 map loaded with tactical positions, minimap, sound indicators, and improved AI');
}

setupMinimap() {
  // Minimap configuration - moved to top-left corner as requested
  this.minimap = {
    enabled: true,
    size: 200,
    x: 20, // Top-left corner
    y: 20,
    scale: 0.1, // Map scale factor for minimap
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderColor: '#555',
    playerDotSize: 3,
    wallColor: '#666',
    bombSiteColor: 'rgba(255, 170, 0, 0.3)',
    ctColor: '#4488ff',
    tColor: '#ff8844',
    deadPlayerColor: '#888',
    deadPlayerMarkSize: 8
  };
}

setupBuyMenu() {
  // Setup buy menu tab switching
  document.querySelectorAll('.buy-tab').forEach(tab => {
    tab.addEventListener('click', (e) => {
      const category = e.target.dataset.category;
      this.switchBuyCategory(category);
    });
  });
  
  // Setup buy item clicks
  document.querySelectorAll('.buy-item').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const button = e.currentTarget;
      const weapon = button.dataset.weapon;
      const price = parseInt(button.dataset.price);
      const type = button.dataset.type;
      const team = button.dataset.team;
      
      this.buyWeapon(weapon, price, type, team);
    });
  });
  
  // Update buy menu on open
  const buyMenu = document.getElementById('buy-menu');
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
        if (buyMenu.style.display === 'block') {
          this.updateBuyMenu();
        }
      }
    });
  });
  observer.observe(buyMenu, { attributes: true });
}

spawnEnemies() {
  // 生成 AI 敵人 using tactical spawn points
  for (let i = 0; i < 3; i++) {
    const enemyTeam = this.localPlayer.team === 'ct' ? 't' : 'ct';
    const spawnPoints = this.gameState.map.spawns[enemyTeam];
    const spawnIndex = Math.min(i, spawnPoints.length - 1);
    const spawnPoint = spawnPoints[spawnIndex];
    
    this.enemies.push({
      id: 'enemy-' + i,
      name: 'Bot' + i,
      team: enemyTeam,
      x: spawnPoint.x + (Math.random() - 0.5) * 40, // Add some randomness
      y: spawnPoint.y + (Math.random() - 0.5) * 40,
      angle: Math.random() * Math.PI * 2,
      health: 100,
      armor: 0,
      alive: true,
      lastShoot: 0,
      moveTimer: 0,
      hasLineOfSight: false,
      lastSeenPlayer: 0
    });
  }
  
  console.log(`Spawned ${this.enemies.length} enemies using tactical spawn points`);
}

// Helper function to get a random spawn point for a team
getRandomSpawnPoint(team) {
  const spawns = this.gameState.map.spawns[team];
  if (!spawns || spawns.length === 0) {
    // Fallback to old spawn system
    console.warn(`No spawn points found for team ${team}, using fallback`);
    return team === 'ct' ? { x: 1650, y: 300 } : { x: 200, y: 900 };
  }
  
  const randomIndex = Math.floor(Math.random() * spawns.length);
  const baseSpawn = spawns[randomIndex];
  
  // Add slight randomness to avoid players spawning on top of each other
  return {
    x: baseSpawn.x + (Math.random() - 0.5) * 30,
    y: baseSpawn.y + (Math.random() - 0.5) * 30
  };
}

handleMovement() {
  if (!this.localPlayer.alive) return;
  
  let dx = 0, dy = 0;
  if (this.keys['w']) dy = -1;
  if (this.keys['s']) dy = 1;
  if (this.keys['a']) dx = -1;
  if (this.keys['d']) dx = 1;
  
  if (dx !== 0 || dy !== 0) {
    const isRunning = this.keys['shift'];
    const speed = isRunning ? 7 : 5;
    const angle = Math.atan2(dy, dx);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    
    const newX = this.localPlayer.x + vx;
    const newY = this.localPlayer.y + vy;
    
    // Determine surface type for footstep sounds
    const surface = this.getSurfaceType(newX, newY);
    
    // Adjust footstep interval based on movement speed
    this.footstepInterval = isRunning ? 300 : 500;
    
    // Debug: Show movement info
    console.log('Moving:', {dx, dy, vx, vy, newX, newY});
    
    // Simplified collision check to ensure movement works
    // Boundary check
    const mapWidth = this.gameState.map ? this.gameState.map.width : 1600;
    const mapHeight = this.gameState.map ? this.gameState.map.height : 900;
    
    if (newX > 15 && newX < mapWidth - 15 && 
        newY > 15 && newY < mapHeight - 15) {
      // Check wall collisions only
      let canMove = true;
      if (this.gameState.map && this.gameState.map.walls) {
        for (const wall of this.gameState.map.walls) {
          if (newX + 15 > wall.x && 
              newX - 15 < wall.x + wall.width &&
              newY + 15 > wall.y && 
              newY - 15 < wall.y + wall.height) {
            canMove = false;
            break;
          }
        }
      }
      
      if (canMove) {
        this.localPlayer.x = newX;
        this.localPlayer.y = newY;
        
        // Play footstep sound based on surface type
        this.playFootstepSound(surface, newX, newY);
        
        // Update 3D audio listener position
        this.updateListener3DPosition();
      }
    }
  }
  
  // Update player's facing angle to match aim
  this.localPlayer.angle = this.aimAngle;
}

getSurfaceType(x, y) {
  // Determine surface type based on position and map features
  if (!this.gameState.map) return 'concrete';
  
  // Check if position is on a metal surface (like pipes or vents)
  if (this.gameState.map.walls) {
    for (const wall of this.gameState.map.walls) {
      if (x >= wall.x && x <= wall.x + wall.width &&
          y >= wall.y && y <= wall.y + wall.height) {
        // Large walls are typically concrete, small walls/pipes are metal
        return wall.width > 100 ? 'concrete' : 'metal';
      }
    }
  }
  
  // Check for specific surface areas (can be expanded with map data)
  // For now, use simple position-based detection
  if (x < 200 || x > 1400 || y < 100 || y > 700) {
    return 'metal'; // Border areas are metal
  }
  
  // Check for water areas (near bomb sites or specific map regions)
  if (this.gameState.map.bombSites) {
    for (const site of Object.values(this.gameState.map.bombSites)) {
      const dist = Math.hypot(x - site.x, y - site.y);
      if (dist < 80) {
        return 'wood'; // Near bomb sites have wooden surfaces
      }
    }
  }
  
  // Random variation for more interesting audio
  const random = (Math.floor(x / 100) + Math.floor(y / 100)) % 10;
  if (random < 2) return 'wood';
  if (random < 4) return 'metal';
  
  return 'concrete'; // Default surface
}

// Calculate aim angle based on mouse position
updateAimAngle() {
  if (!this.localPlayer.alive) return;
  
  // Get player's screen position (center of screen due to camera)
  const screenCenterX = this.canvas.width / 2;
  const screenCenterY = this.canvas.height / 2;
  
  // Calculate angle from player (screen center) to mouse
  const dx = this.mouseX - screenCenterX;
  const dy = this.mouseY - screenCenterY;
  
  this.aimAngle = Math.atan2(dy, dx);
}

checkCollision(x, y, radius) {
  // 邊界檢查
  if (x - radius < 0 || x + radius > this.gameState.map.width) return true;
  if (y - radius < 0 || y + radius > this.gameState.map.height) return true;
  
  // 牆壁碰撞 - enhanced with precise rectangle collision
  for (const wall of this.gameState.map.walls) {
    if (this.circleRectangleCollision(x, y, radius, wall)) {
      return true;
    }
  }
  
  return false;
}

// Enhanced circle-rectangle collision detection
circleRectangleCollision(circleX, circleY, circleRadius, rect) {
  const closestX = Math.max(rect.x, Math.min(circleX, rect.x + rect.width));
  const closestY = Math.max(rect.y, Math.min(circleY, rect.y + rect.height));
  
  const distanceX = circleX - closestX;
  const distanceY = circleY - closestY;
  
  return (distanceX * distanceX + distanceY * distanceY) < (circleRadius * circleRadius);
}

// Line-of-sight calculation for shooting and AI visibility
hasLineOfSight(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const distance = Math.hypot(dx, dy);
  const steps = Math.ceil(distance / 5); // Check every 5 pixels
  
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const checkX = x1 + dx * t;
    const checkY = y1 + dy * t;
    
    // Check if this point intersects with any wall
    for (const wall of this.gameState.map.walls) {
      if (checkX >= wall.x && checkX <= wall.x + wall.width &&
          checkY >= wall.y && checkY <= wall.y + wall.height) {
        return false; // Line blocked by wall
      }
    }
  }
  
  return true; // Clear line of sight
}

// Advanced line-of-sight with material-based penetration
bulletLineOfSight(x1, y1, x2, y2, penetrationPower = 1) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const distance = Math.hypot(dx, dy);
  const steps = Math.ceil(distance / 2); // More precise for bullets
  let penetrationUsed = 0;
  let totalDamageReduction = 0;
  const penetratedWalls = [];
  
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const checkX = x1 + dx * t;
    const checkY = y1 + dy * t;
    
    // Check wall penetration with material properties
    for (const wall of this.gameState.map.walls) {
      if (checkX >= wall.x && checkX <= wall.x + wall.width &&
          checkY >= wall.y && checkY <= wall.y + wall.height) {
        
        // Determine wall material (can be enhanced later with actual material data)
        let material = this.MATERIALS.CONCRETE; // Default
        if (wall.width < 20 || wall.height < 20) {
          material = this.MATERIALS.THIN_WALL;
        } else if (wall.width > 50 && wall.height > 50) {
          material = this.MATERIALS.THICK_WALL;
        }
        
        // Check if we can penetrate this material
        const materialPenetrationRequired = material.penetrationResistance;
        if (penetrationPower >= materialPenetrationRequired) {
          penetrationUsed += materialPenetrationRequired;
          totalDamageReduction += material.damageReduction;
          penetratedWalls.push({ wall, material, hitPoint: { x: checkX, y: checkY } });
          
          // Check if we've exceeded our penetration power
          if (penetrationUsed > penetrationPower) {
            return { 
              blocked: true, 
              hitPoint: { x: checkX, y: checkY }, 
              wall: wall,
              penetratedWalls: penetratedWalls,
              damageReduction: Math.min(0.9, totalDamageReduction) // Cap at 90% reduction
            };
          }
        } else {
          // Can't penetrate this material
          return { 
            blocked: true, 
            hitPoint: { x: checkX, y: checkY }, 
            wall: wall,
            penetratedWalls: penetratedWalls,
            damageReduction: Math.min(0.9, totalDamageReduction)
          };
        }
      }
    }
  }
  
  return { 
    blocked: false, 
    penetrationUsed: penetrationUsed,
    penetratedWalls: penetratedWalls,
    damageReduction: Math.min(0.9, totalDamageReduction)
  };
}

// Sound propagation check (for footsteps, gunshots, etc.)
canHearSound(sourceX, sourceY, listenerX, listenerY, soundType) {
  const distance = Math.hypot(listenerX - sourceX, listenerY - sourceY);
  const maxRange = this.gameState.map.soundRanges[soundType] || 100;
  
  if (distance > maxRange) return false;
  
  // Check if walls block or muffle sound
  const wallsBetween = this.countWallsBetween(sourceX, sourceY, listenerX, listenerY);
  const attenuationFactor = Math.max(0.1, 1 - (wallsBetween * 0.3)); // Each wall reduces sound by 30%
  
  return (distance / maxRange) < attenuationFactor;
}

// Count walls between two points (for sound attenuation)
countWallsBetween(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const distance = Math.hypot(dx, dy);
  const steps = Math.ceil(distance / 10);
  let wallCount = 0;
  let inWall = false;
  
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const checkX = x1 + dx * t;
    const checkY = y1 + dy * t;
    
    let currentlyInWall = false;
    for (const wall of this.gameState.map.walls) {
      if (checkX >= wall.x && checkX <= wall.x + wall.width &&
          checkY >= wall.y && checkY <= wall.y + wall.height) {
        currentlyInWall = true;
        break;
      }
    }
    
    if (currentlyInWall && !inWall) {
      wallCount++;
    }
    inWall = currentlyInWall;
  }
  
  return wallCount;
}

// Validate spawn position is safe
validateSpawnPosition(x, y) {
  const playerRadius = 15;
  
  // Check if spawn position collides with any walls
  if (this.checkCollision(x, y, playerRadius)) {
    console.warn(`Spawn position (${x}, ${y}) collides with walls!`);
    return false;
  }
  
  return true;
}

shoot() {
  if (!this.localPlayer.alive || this.localPlayer.frozen || this.gameState.bombAction) return;
  
  // Check if switching weapons
  if (this.weaponSystem.switchingWeapon) return;
  
  const currentWeapon = this.getCurrentWeapon();
  if (!currentWeapon) return;
  
  const now = Date.now();
  if (now - this.weaponSystem.lastShotTime < currentWeapon.firerate) return;
  if (currentWeapon.ammo.clip <= 0) {
    this.showNotification('Need to reload!');
    this.playEmptySound();
    return;
  }
  
  this.weaponSystem.lastShotTime = now;
  currentWeapon.ammo.clip--;
  this.weaponSystem.bulletCount++;
  
  // Track shot statistics
  this.updateRoundStats('shot');
  
  // Calculate accuracy based on movement and weapon properties
  const isMoving = this.keys['w'] || this.keys['a'] || this.keys['s'] || this.keys['d'];
  const baseAccuracy = isMoving ? currentWeapon.accuracy.moving : currentWeapon.accuracy.standing;
  
  // First shot accuracy bonus
  const timeSinceLastShot = now - this.weaponSystem.lastShotTime;
  const isFirstShot = timeSinceLastShot > 1000 || this.weaponSystem.recoilStep === 0;
  const accuracy = isFirstShot ? currentWeapon.accuracy.firstShot : baseAccuracy;
  
  // Calculate recoil
  this.applyRecoil(currentWeapon);
  
  // Calculate bullet spread based on accuracy
  const spread = (1 - accuracy) * currentWeapon.recoil.maxSpread;
  const spreadX = (Math.random() - 0.5) * spread;
  const spreadY = (Math.random() - 0.5) * spread;
  
  // Apply recoil to aim angle
  const recoilAngle = this.aimAngle + 
    (this.weaponSystem.currentRecoil.x * Math.PI / 180) +
    (this.weaponSystem.currentRecoil.y * Math.PI / 180);
  
  const finalAngle = recoilAngle + (spreadX * Math.PI / 180);
  const bulletSpeed = 25; // Increased bullet speed for better hit registration
  
  // Determine damage based on weapon's damage ranges
  const weaponDamage = currentWeapon.damage;
  let baseDamage;
  if (typeof weaponDamage === 'object') {
    baseDamage = weaponDamage.close; // Start with close range damage, will be adjusted by distance
  } else {
    baseDamage = weaponDamage; // Fallback for old weapon format
  }
  
  // Create bullet with enhanced properties
  const bullet = {
    x: this.localPlayer.x,
    y: this.localPlayer.y,
    vx: Math.cos(finalAngle) * bulletSpeed,
    vy: Math.sin(finalAngle) * bulletSpeed,
    damage: baseDamage,
    weaponDamage: weaponDamage, // Store full damage object for distance calculation
    penetration: currentWeapon.penetration || 1,
    owner: this.localPlayer.id,
    team: this.localPlayer.team,
    life: 60,
    weaponType: currentWeapon.type,
    isTracer: this.weaponSystem.bulletCount % 3 === 0, // Every 3rd bullet is a tracer
    startTime: now
  };
  
  this.gameState.bullets.push(bullet);
  
  // Muzzle flash effect
  this.weaponSystem.muzzleFlash = {
    active: true,
    startTime: now,
    duration: 100,
    x: this.localPlayer.x + Math.cos(this.aimAngle) * 25,
    y: this.localPlayer.y + Math.sin(this.aimAngle) * 25,
    angle: this.aimAngle
  };
  
  // Screen shake effect (stronger for more powerful weapons)
  if (currentWeapon.screenShake) {
    this.weaponSystem.screenShake = {
      x: (Math.random() - 0.5) * currentWeapon.screenShake,
      y: (Math.random() - 0.5) * currentWeapon.screenShake,
      intensity: currentWeapon.screenShake,
      decay: 0.85
    };
  } else {
    // Default screen shake for all weapons
    const shakeIntensity = currentWeapon.type === 'rifle' ? 2 : 1;
    this.weaponSystem.screenShake = {
      x: (Math.random() - 0.5) * shakeIntensity,
      y: (Math.random() - 0.5) * shakeIntensity,
      intensity: shakeIntensity,
      decay: 0.9
    };
  }
  
  // Play shooting sound effect
  this.playShootSound();
  
  this.updateAmmoDisplay();
}

// Apply recoil pattern to weapon
applyRecoil(weapon) {
  if (!weapon.recoil || !weapon.recoil.pattern) return;
  
  const pattern = weapon.recoil.pattern;
  const patternIndex = this.weaponSystem.recoilStep % pattern.length;
  
  // Get recoil values from pattern (alternating x, y)
  const recoilX = pattern[patternIndex * 2] || 0;
  const recoilY = pattern[patternIndex * 2 + 1] || 0;
  
  // Apply recoil with some randomization
  this.weaponSystem.currentRecoil.x += recoilX * (0.8 + Math.random() * 0.4);
  this.weaponSystem.currentRecoil.y += recoilY * (0.8 + Math.random() * 0.4);
  
  // Increment recoil step
  this.weaponSystem.recoilStep++;
  
  // Cap maximum recoil
  const maxSpread = weapon.recoil.maxSpread;
  this.weaponSystem.currentRecoil.x = Math.max(-maxSpread, Math.min(maxSpread, this.weaponSystem.currentRecoil.x));
  this.weaponSystem.currentRecoil.y = Math.max(-maxSpread, Math.min(maxSpread, this.weaponSystem.currentRecoil.y));
}

// Recover recoil over time
updateRecoilRecovery() {
  const now = Date.now();
  const timeSinceShot = now - this.weaponSystem.lastShotTime;
  
  if (timeSinceShot > 200) { // Start recovery after 200ms
    const currentWeapon = this.getCurrentWeapon();
    const recoveryRate = currentWeapon?.recoil?.recovery || 0.5;
    
    // Recover recoil
    this.weaponSystem.currentRecoil.x *= (1 - recoveryRate * 0.1);
    this.weaponSystem.currentRecoil.y *= (1 - recoveryRate * 0.1);
    
    // Reset recoil step if recoil is low enough
    if (Math.abs(this.weaponSystem.currentRecoil.x) < 0.5 && 
        Math.abs(this.weaponSystem.currentRecoil.y) < 0.5) {
      this.weaponSystem.recoilStep = 0;
      this.weaponSystem.currentRecoil.x = 0;
      this.weaponSystem.currentRecoil.y = 0;
    }
  }
}

// Quick switch to previous weapon (Q key)
quickSwitchWeapon() {
  if (!this.localPlayer.alive || this.weaponSystem.switchingWeapon) return;
  
  const currentSlot = this.localPlayer.currentWeapon;
  const newSlot = currentSlot === 'primary' ? 'secondary' : 'primary';
  
  // Check if target weapon exists
  if (!this.localPlayer.weapons[newSlot]) {
    this.showNotification('No weapon to switch to!');
    return;
  }
  
  this.switchWeapon(newSlot);
}

// Enhanced weapon switching with delays and animations
switchWeapon(slot) {
  if (!this.localPlayer.alive || this.weaponSystem.switchingWeapon) return;
  if (this.localPlayer.currentWeapon === slot) return;
  if (!this.localPlayer.weapons[slot]) return;
  
  const targetWeapon = this.localPlayer.weapons[slot];
  
  // Start weapon switch with delay
  this.weaponSystem.switchingWeapon = true;
  this.weaponSystem.switchStartTime = Date.now();
  this.weaponSystem.lastWeapon = this.localPlayer.currentWeapon;
  
  // Show switching indicator
  this.showNotification(`Switching to ${targetWeapon.name}...`);
  
  // Complete the switch after the weapon's switch time
  setTimeout(() => {
    if (this.weaponSystem.switchingWeapon) {
      this.localPlayer.currentWeapon = slot;
      this.weaponSystem.switchingWeapon = false;
      this.updateWeaponDisplay();
      this.updateAmmoDisplay();
      
      // Reset recoil when switching weapons
      this.weaponSystem.currentRecoil = { x: 0, y: 0 };
      this.weaponSystem.recoilStep = 0;
    }
  }, targetWeapon.switchTime * 1000);
}

// Visual effect functions
createBulletImpact(x, y, wall, bulletDirection = { x: 0, y: 0 }) {
  // Create enhanced sparks or dust based on wall material
  const isMetal = wall.width > 50;
  const impact = {
    x: x,
    y: y,
    particles: [],
    startTime: Date.now(),
    duration: isMetal ? 500 : 400,
    type: 'impact'
  };
  
  const particleCount = isMetal ? 8 : 6;
  const baseVelocity = isMetal ? 10 : 6;
  
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = (0.5 + Math.random() * 0.5) * baseVelocity;
    
    // Reflect particles away from the wall
    let vx = Math.cos(angle) * speed;
    let vy = Math.sin(angle) * speed;
    
    // Add some reflection based on bullet direction
    if (bulletDirection.x !== 0 || bulletDirection.y !== 0) {
      vx += bulletDirection.x * 0.3;
      vy += bulletDirection.y * 0.3;
    }
    
    impact.particles.push({
      x: x + (Math.random() - 0.5) * 5,
      y: y + (Math.random() - 0.5) * 5,
      vx: vx,
      vy: vy,
      life: isMetal ? 30 : 20,
      maxLife: isMetal ? 30 : 20,
      size: isMetal ? 1.5 : 2,
      color: isMetal ? '#ffaa00' : '#999999',
      type: isMetal ? 'spark' : 'dust',
      gravity: isMetal ? 0.05 : 0.15,
      friction: isMetal ? 0.97 : 0.95
    });
  }
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(impact);
  
  // Add bullet hole decal for concrete walls
  if (!isMetal) {
    this.addBulletHole(x, y);
  }
}

createPenetrationEffect(x, y, material) {
  // Create dust/debris effect when bullet penetrates
  const effect = {
    x: x,
    y: y,
    particles: [],
    startTime: Date.now(),
    duration: 200,
    type: 'penetration'
  };
  
  const particleCount = 3;
  for (let i = 0; i < particleCount; i++) {
    effect.particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 15,
      color: '#bbbbbb'
    });
  }
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(effect);
}

createHitEffect(x, y, isCritical = false) {
  // Create enhanced blood splatter effect
  const effect = {
    x: x,
    y: y,
    particles: [],
    startTime: Date.now(),
    duration: 800,
    type: 'blood'
  };
  
  const particleCount = isCritical ? 12 : 8;
  const bloodColors = ['#ff3333', '#cc1111', '#ff4444', '#aa2222'];
  
  for (let i = 0; i < particleCount; i++) {
    const velocity = isCritical ? 8 : 5;
    const size = 1 + Math.random() * (isCritical ? 3 : 2);
    
    effect.particles.push({
      x: x + (Math.random() - 0.5) * 10,
      y: y + (Math.random() - 0.5) * 10,
      vx: (Math.random() - 0.5) * velocity,
      vy: (Math.random() - 0.5) * velocity,
      life: 40 + Math.random() * 20,
      maxLife: 40 + Math.random() * 20,
      size: size,
      color: bloodColors[Math.floor(Math.random() * bloodColors.length)],
      gravity: 0.1,
      friction: 0.98
    });
  }
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(effect);
  
  // Create a hit marker for feedback
  this.createHitMarker(x, y, isCritical);
}

showDamageNumber(x, y, damage, isCritical = false) {
  // Create floating damage number
  const damageNumber = {
    x: x + (Math.random() - 0.5) * 20, // Add some random spread
    y: y,
    damage: damage,
    startTime: Date.now(),
    duration: isCritical ? 1500 : 1000,
    type: 'damage',
    isCritical: isCritical
  };
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(damageNumber);
}

// New enhanced visual effect functions
addBulletHole(x, y) {
  // Add bullet hole decal that persists on the map
  if (!this.gameState.bulletHoles) {
    this.gameState.bulletHoles = [];
  }
  
  this.gameState.bulletHoles.push({
    x: x,
    y: y,
    size: 3 + Math.random() * 2,
    rotation: Math.random() * Math.PI * 2,
    alpha: 0.6 + Math.random() * 0.4,
    createdTime: Date.now()
  });
  
  // Limit bullet holes to prevent memory issues
  if (this.gameState.bulletHoles.length > 50) {
    this.gameState.bulletHoles.shift();
  }
}

createHitMarker(x, y, isCritical = false) {
  // Create hit marker for player feedback
  if (!this.gameState.hitMarkers) {
    this.gameState.hitMarkers = [];
  }
  
  this.gameState.hitMarkers.push({
    x: x,
    y: y,
    startTime: Date.now(),
    duration: isCritical ? 300 : 200,
    size: isCritical ? 20 : 15,
    color: isCritical ? '#ff4444' : '#ffffff',
    isCritical: isCritical
  });
}

createExplosionEffect(x, y, size = 50) {
  // Create explosion effect for bombs and grenades
  const explosion = {
    x: x,
    y: y,
    size: size,
    particles: [],
    startTime: Date.now(),
    duration: 1000,
    type: 'explosion'
  };
  
  // Generate explosion particles
  const particleCount = 20;
  for (let i = 0; i < particleCount; i++) {
    const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
    const speed = 5 + Math.random() * 10;
    const distance = size * (0.5 + Math.random() * 0.5);
    
    explosion.particles.push({
      x: x + Math.cos(angle) * 10,
      y: y + Math.sin(angle) * 10,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 60,
      maxLife: 60,
      size: 2 + Math.random() * 3,
      color: `rgb(${255 - Math.floor(Math.random() * 100)}, ${100 + Math.floor(Math.random() * 100)}, 0)`,
      gravity: 0.1,
      friction: 0.98
    });
  }
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(explosion);
}

createDeathEffect(x, y, playerName) {
  // Create death effect with ragdoll-like animation
  const deathEffect = {
    x: x,
    y: y,
    particles: [],
    startTime: Date.now(),
    duration: 2000,
    type: 'death',
    playerName: playerName
  };
  
  // Create blood splatter
  const bloodCount = 15;
  for (let i = 0; i < bloodCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 3 + Math.random() * 5;
    
    deathEffect.particles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 80,
      maxLife: 80,
      size: 1 + Math.random() * 2,
      color: '#aa1111',
      gravity: 0.15,
      friction: 0.95
    });
  }
  
  this.gameState.visualEffects = this.gameState.visualEffects || [];
  this.gameState.visualEffects.push(deathEffect);
}

renderHitMarkers() {
  // Render hit markers for player feedback
  if (!this.gameState.hitMarkers) return;
  
  const now = Date.now();
  this.gameState.hitMarkers = this.gameState.hitMarkers.filter(marker => {
    const age = now - marker.startTime;
    const progress = age / marker.duration;
    
    if (progress >= 1) return false;
    
    const alpha = 1 - progress;
    const scale = 1 + progress * 0.5;
    
    this.ctx.save();
    this.ctx.translate(marker.x, marker.y);
    this.ctx.scale(scale, scale);
    this.ctx.strokeStyle = marker.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba').replace('#', 'rgba(255,255,255,').replace('ffffff', '255,255,255').replace('ff4444', '255,68,68');
    this.ctx.lineWidth = marker.isCritical ? 3 : 2;
    this.ctx.lineCap = 'round';
    
    // Draw X shape for hit marker
    this.ctx.beginPath();
    this.ctx.moveTo(-marker.size/2, -marker.size/2);
    this.ctx.lineTo(marker.size/2, marker.size/2);
    this.ctx.moveTo(marker.size/2, -marker.size/2);
    this.ctx.lineTo(-marker.size/2, marker.size/2);
    this.ctx.stroke();
    
    this.ctx.restore();
    return true;
  });
}

renderBulletHoles() {
  // Render persistent bullet holes
  if (!this.gameState.bulletHoles) return;
  
  const now = Date.now();
  this.gameState.bulletHoles.forEach(hole => {
    // Fade out bullet holes after 30 seconds
    const age = now - hole.createdTime;
    const fadeTime = 30000; // 30 seconds
    const alpha = age > fadeTime ? Math.max(0, 1 - (age - fadeTime) / fadeTime) : hole.alpha;
    
    if (alpha > 0.05) {
      this.ctx.save();
      this.ctx.translate(hole.x, hole.y);
      this.ctx.rotate(hole.rotation);
      this.ctx.fillStyle = `rgba(30, 30, 30, ${alpha})`;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, hole.size, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.restore();
    }
  });
  
  // Clean up very old bullet holes
  this.gameState.bulletHoles = this.gameState.bulletHoles.filter(hole => {
    const age = now - hole.createdTime;
    return age < 60000; // Remove after 60 seconds
  });
}

// Update weapon system mechanics
updateWeaponSystem() {
  // Update recoil recovery
  this.updateRecoilRecovery();
  
  // Update screen shake
  if (this.weaponSystem.screenShake.intensity > 0.1) {
    this.weaponSystem.screenShake.x *= this.weaponSystem.screenShake.decay;
    this.weaponSystem.screenShake.y *= this.weaponSystem.screenShake.decay;
    this.weaponSystem.screenShake.intensity *= this.weaponSystem.screenShake.decay;
  } else {
    this.weaponSystem.screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9 };
  }
  
  // Update muzzle flash
  if (this.weaponSystem.muzzleFlash.active) {
    const now = Date.now();
    if (now - this.weaponSystem.muzzleFlash.startTime > this.weaponSystem.muzzleFlash.duration) {
      this.weaponSystem.muzzleFlash.active = false;
    }
  }
  
  // Update movement detection for accuracy
  this.weaponSystem.isMoving = this.keys['w'] || this.keys['a'] || this.keys['s'] || this.keys['d'];
}

// Update all visual effects
updateVisualEffects() {
  if (!this.gameState.visualEffects) return;
  
  const now = Date.now();
  this.gameState.visualEffects = this.gameState.visualEffects.filter(effect => {
    const age = now - effect.startTime;
    
    if (age > effect.duration) return false;
    
    // Update particles if they exist
    if (effect.particles) {
      effect.particles = effect.particles.filter(particle => {
        // Apply velocity
        particle.x += particle.vx;
        particle.y += particle.vy;
        
        // Apply gravity if present
        if (particle.gravity) {
          particle.vy += particle.gravity;
        }
        
        // Apply friction if present, otherwise default air resistance
        const frictionValue = particle.friction || 0.95;
        particle.vx *= frictionValue;
        particle.vy *= frictionValue;
        
        // Update life
        particle.life--;
        
        return particle.life > 0;
      });
    }
    
    // Update damage numbers (float upward)
    if (effect.type === 'damage') {
      effect.y -= 1;
    }
    
    return true;
  });
}

reload() {
  if (!this.localPlayer.alive || this.localPlayer.frozen || this.gameState.bombAction) return;
  
  const currentWeapon = this.getCurrentWeapon();
  if (!currentWeapon) return;
  
  const maxClip = currentWeapon.ammo.clip + currentWeapon.ammo.reserve <= 
    (currentWeapon.name.includes('AWP') ? 10 : 
     currentWeapon.name.includes('Deagle') ? 7 : 30);
  
  if (currentWeapon.ammo.clip >= maxClip) return;
  if (currentWeapon.ammo.reserve <= 0) return;
  
  const needed = maxClip - currentWeapon.ammo.clip;
  const available = Math.min(needed, currentWeapon.ammo.reserve);
  
  currentWeapon.ammo.clip += available;
  currentWeapon.ammo.reserve -= available;
  
  // Play reload sound
  this.playReloadSound();
  
  this.updateAmmoDisplay();
  this.showNotification('Reload complete!');
}

interact() {
  // Check for weapon pickup first
  const nearbyWeapon = this.checkWeaponPickup();
  if (nearbyWeapon) {
    this.pickupWeapon(nearbyWeapon);
    return;
  }
  
  // 檢查是否在炸彈點
  for (const site of this.gameState.map.bombSites) {
    const dist = Math.hypot(this.localPlayer.x - site.x, this.localPlayer.y - site.y);
    if (dist < site.radius) {
      if (this.localPlayer.team === 't' && !this.gameState.bombPlanted) {
        this.startPlantingBomb(site);
      } else if (this.localPlayer.team === 'ct' && this.gameState.bombPlanted) {
        this.startDefusingBomb();
      }
      return;
    }
  }
}

startPlantingBomb(site) {
  this.gameState.bombAction = 'planting';
  this.gameState.bombProgress = 0;
  this.gameState.bombActionStartTime = Date.now();
  this.gameState.bombSite = site;
  this.showBombProgress('Planting bomb...', 'plant');
}

startDefusingBomb() {
  this.gameState.bombAction = 'defusing';
  this.gameState.bombProgress = 0;
  this.gameState.bombActionStartTime = Date.now();
  const defuseTime = this.localPlayer.hasDefuseKit ? 5 : 10;
  this.showBombProgress(`Defusing bomb... (${defuseTime}s)`, 'defuse');
}

stopBombAction() {
  this.gameState.bombAction = null;
  this.gameState.bombProgress = 0;
  this.hideBombProgress();
  this.showNotification('Action cancelled!');
}

plantBomb(site) {
  this.gameState.bombPlanted = true;
  this.gameState.bombTimer = 45;
  this.gameState.bombSite = site;
  this.gameState.bombAction = null;
  this.gameState.bombProgress = 0;
  
  this.hideBombProgress();
  this.showNotification('Bomb planted!');
  document.getElementById('bomb-indicator').style.display = 'block';
  
  // Play voice line
  this.playVoiceLine('bombPlanted');
  
  // Award bomb plant bonus to T team
  if (this.localPlayer.team === 't') {
    this.addMoney(this.ECONOMY.BOMB_PLANT_REWARD);
    this.showEconomyNotification(`Bomb plant bonus: +$${this.ECONOMY.BOMB_PLANT_REWARD}`, 'success');
  }
}

defuseBomb() {
  this.gameState.bombPlanted = false;
  this.showNotification('Bomb defused! CT wins!');
  document.getElementById('bomb-indicator').style.display = 'none';
  
  // Play voice line
  this.playVoiceLine('bombDefused');
  
  this.endRound('ct');
}

quickBuy(key) {
  const quickBuys = {
    '3': { weapon: 'awp', price: 4750, type: 'rifle' },
    '4': { weapon: 'deagle', price: 650, type: 'pistol' },
    '5': { weapon: 'kevlar', price: 650, type: 'equipment' }
  };
  
  if (quickBuys[key]) {
    const buy = quickBuys[key];
    this.buyWeapon(buy.weapon, buy.price, buy.type);
  }
}

updateAI() {
  this.enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    const dist = Math.hypot(this.localPlayer.x - enemy.x, this.localPlayer.y - enemy.y);
    const hasLOS = this.hasLineOfSight(enemy.x, enemy.y, this.localPlayer.x, this.localPlayer.y);
    const canHearPlayer = this.canHearSound(this.localPlayer.x, this.localPlayer.y, enemy.x, enemy.y, 'footsteps');
    
    // Enhanced AI behavior based on line of sight and sound
    if (hasLOS && dist < 600 && this.localPlayer.alive) {
      // Enemy can see player - aggressive mode
      enemy.hasLineOfSight = true;
      enemy.lastSeenPlayer = Date.now();
      
      // Aim at player
      const targetAngle = Math.atan2(this.localPlayer.y - enemy.y, this.localPlayer.x - enemy.x);
      enemy.angle = targetAngle;
      
      // Move toward player (but not too close)
      if (dist > 200) {
        const speed = 2;
        const newX = enemy.x + Math.cos(targetAngle) * speed;
        const newY = enemy.y + Math.sin(targetAngle) * speed;
        
        if (!this.checkCollision(newX, newY, 15)) {
          enemy.x = newX;
          enemy.y = newY;
        }
      }
      
      // Shoot at player
      const now = Date.now();
      if (now - enemy.lastShoot > 600) { // Slower fire rate for balance
        enemy.lastShoot = now;
        
        this.gameState.bullets.push({
          x: enemy.x,
          y: enemy.y,
          vx: Math.cos(targetAngle) * 20,
          vy: Math.sin(targetAngle) * 20,
          damage: 25, // Slightly reduced damage
          penetration: 1,
          owner: enemy.id,
          team: enemy.team,
          life: 60,
          weaponType: 'rifle'
        });
      }
      
    } else if (canHearPlayer && this.localPlayer.alive) {
      // Enemy can hear player but can't see them - investigate
      enemy.hasLineOfSight = false;
      const soundAngle = Math.atan2(this.localPlayer.y - enemy.y, this.localPlayer.x - enemy.x);
      
      // Move cautiously toward sound
      const speed = 1.5;
      const newX = enemy.x + Math.cos(soundAngle) * speed;
      const newY = enemy.y + Math.sin(soundAngle) * speed;
      
      if (!this.checkCollision(newX, newY, 15)) {
        enemy.x = newX;
        enemy.y = newY;
        enemy.angle = soundAngle;
      }
      
    } else if (enemy.lastSeenPlayer && (Date.now() - enemy.lastSeenPlayer < 3000)) {
      // Enemy lost sight of player recently - search mode
      enemy.hasLineOfSight = false;
      
      // Move toward last known position
      const speed = 2;
      const searchAngle = enemy.angle + (Math.random() - 0.5) * 0.5; // Add some randomness
      const newX = enemy.x + Math.cos(searchAngle) * speed;
      const newY = enemy.y + Math.sin(searchAngle) * speed;
      
      if (!this.checkCollision(newX, newY, 15)) {
        enemy.x = newX;
        enemy.y = newY;
        enemy.angle = searchAngle;
      } else {
        // Hit wall, change direction
        enemy.angle += Math.PI * 0.5;
      }
      
    } else {
      // Enhanced tactical positioning behavior
      enemy.hasLineOfSight = false;
      enemy.lastSeenPlayer = 0;
      
      // Initialize tactical target if not set
      if (!enemy.tacticalTarget) {
        enemy.tacticalTarget = this.selectTacticalPosition(enemy);
        enemy.tacticalTargetReached = false;
      }
      
      enemy.moveTimer++;
      
      // Check if we've reached the tactical position
      if (enemy.tacticalTarget) {
        const distToTarget = Math.hypot(enemy.tacticalTarget.x - enemy.x, enemy.tacticalTarget.y - enemy.y);
        
        if (distToTarget < 50) {
          enemy.tacticalTargetReached = true;
          // Hold position for a while, then select new target
          if (enemy.moveTimer > 300) { // Hold for 5 seconds
            enemy.tacticalTarget = this.selectTacticalPosition(enemy);
            enemy.tacticalTargetReached = false;
            enemy.moveTimer = 0;
          }
        } else if (!enemy.tacticalTargetReached) {
          // Move toward tactical position
          const targetAngle = Math.atan2(enemy.tacticalTarget.y - enemy.y, enemy.tacticalTarget.x - enemy.x);
          const speed = 1.5; // Moderate patrol speed
          const newX = enemy.x + Math.cos(targetAngle) * speed;
          const newY = enemy.y + Math.sin(targetAngle) * speed;
          
          if (!this.checkCollision(newX, newY, 15)) {
            enemy.x = newX;
            enemy.y = newY;
            enemy.angle = targetAngle;
          } else {
            // Path blocked, select new tactical target
            enemy.tacticalTarget = this.selectTacticalPosition(enemy);
            enemy.moveTimer = 0;
          }
        }
      }
      
      // Fallback patrol if no tactical target
      if (enemy.moveTimer > 180 && !enemy.tacticalTarget) { // Slower patrol changes
        enemy.angle += (Math.random() - 0.5) * Math.PI;
        enemy.moveTimer = 0;
        
        const speed = 1;
        const newX = enemy.x + Math.cos(enemy.angle) * speed;
        const newY = enemy.y + Math.sin(enemy.angle) * speed;
        
        if (!this.checkCollision(newX, newY, 15)) {
          enemy.x = newX;
          enemy.y = newY;
        } else {
          enemy.angle += Math.PI;
        }
      }
    }
  });
}

// Select tactical position for AI based on team and current game state
selectTacticalPosition(enemy) {
  const tactical = this.gameState.map.tacticalPoints;
  let availablePositions = [];
  
  // Collect relevant tactical positions based on enemy team and role
  if (enemy.team === 'ct') {
    // CT focuses on defensive positions and site holds
    availablePositions = [
      ...tactical.coverSpots.filter(spot => 
        spot.name.includes('A') || spot.name.includes('B') || spot.name.includes('Mid')
      ),
      ...tactical.sniperSpots.filter(spot => 
        spot.coverage.includes('a_site') || spot.coverage.includes('b_site') || spot.coverage.includes('mid')
      )
    ];
  } else {
    // T focuses on aggressive positions and choke points
    availablePositions = [
      ...tactical.chokePoints.filter(choke => choke.importance > 0.5),
      ...tactical.coverSpots.filter(spot => 
        !spot.name.includes('Default') && !spot.name.includes('Quad')
      )
    ];
  }
  
  // Filter positions that are not too close to other enemies
  availablePositions = availablePositions.filter(pos => {
    const tooClose = this.enemies.some(otherEnemy => {
      if (otherEnemy === enemy || !otherEnemy.alive) return false;
      const dist = Math.hypot(pos.x - otherEnemy.x, pos.y - otherEnemy.y);
      return dist < 100; // Don't stack enemies too close
    });
    return !tooClose;
  });
  
  // If no good positions, use any cover spot
  if (availablePositions.length === 0) {
    availablePositions = tactical.coverSpots;
  }
  
  // Select random position from available ones, preferring higher protection/importance
  if (availablePositions.length > 0) {
    // Weight selection by importance/protection
    const weights = availablePositions.map(pos => 
      (pos.importance || pos.protection || 0.5) + Math.random() * 0.3
    );
    
    const maxWeight = Math.max(...weights);
    const bestPositions = availablePositions.filter((pos, i) => 
      weights[i] >= maxWeight - 0.2
    );
    
    return bestPositions[Math.floor(Math.random() * bestPositions.length)];
  }
  
  return null;
}

updateBullets() {
  this.gameState.bullets = this.gameState.bullets.filter(bullet => {
    const prevX = bullet.x;
    const prevY = bullet.y;
    
    bullet.x += bullet.vx;
    bullet.y += bullet.vy;
    bullet.life--;
    
    // Calculate distance traveled for damage falloff
    const distanceTraveled = Math.hypot(bullet.x - bullet.startX || 0, bullet.y - bullet.startY || 0);
    bullet.startX = bullet.startX || prevX;
    bullet.startY = bullet.startY || prevY;
    
    // Enhanced wall collision with material-based penetration
    const penetrationPower = bullet.penetration || 1;
    const lineCheck = this.bulletLineOfSight(prevX, prevY, bullet.x, bullet.y, penetrationPower);
    
    if (lineCheck.blocked) {
      // Create bullet impact effect
      this.createBulletImpact(lineCheck.hitPoint.x, lineCheck.hitPoint.y, lineCheck.wall);
      
      // Bullet stopped by wall
      bullet.x = lineCheck.hitPoint.x;
      bullet.y = lineCheck.hitPoint.y;
      return false;
    } else if (lineCheck.damageReduction > 0) {
      // Bullet penetrated walls - reduce damage based on materials
      bullet.damage *= (1 - lineCheck.damageReduction);
      
      // Create penetration effects for each wall
      lineCheck.penetratedWalls.forEach(wallHit => {
        this.createPenetrationEffect(wallHit.hitPoint.x, wallHit.hitPoint.y, wallHit.material);
      });
    }
    
    // Apply distance-based damage falloff
    if (bullet.weaponDamage && typeof bullet.weaponDamage === 'object') {
      const { close, medium, far } = bullet.weaponDamage;
      let finalDamage;
      
      if (distanceTraveled < 300) { // Close range
        const ratio = distanceTraveled / 300;
        finalDamage = close * (1 - ratio) + medium * ratio;
      } else if (distanceTraveled < 600) { // Medium range  
        const ratio = (distanceTraveled - 300) / 300;
        finalDamage = medium * (1 - ratio) + far * ratio;
      } else { // Far range
        finalDamage = far * Math.max(0.3, 1 - (distanceTraveled - 600) / 1000);
      }
      
      bullet.damage = finalDamage * (bullet.damage / close); // Apply any existing damage multipliers
    }
    
    // Check hit on player
    if (bullet.owner !== this.localPlayer.id && bullet.team !== this.localPlayer.team) {
      const dist = Math.hypot(this.localPlayer.x - bullet.x, this.localPlayer.y - bullet.y);
      if (dist < 15 && this.localPlayer.alive) {
        this.takeDamage(Math.floor(bullet.damage));
        this.createHitEffect(this.localPlayer.x, this.localPlayer.y);
        return false;
      }
    }
    
    // Check hit on enemies
    for (let i = 0; i < this.enemies.length; i++) {
      const enemy = this.enemies[i];
      if (bullet.owner === this.localPlayer.id && enemy.alive) {
        const dist = Math.hypot(enemy.x - bullet.x, enemy.y - bullet.y);
        if (dist < 15) {
          const damage = Math.floor(bullet.damage);
          
          // Calculate critical hit (headshot simulation) - higher chance at close range
          const criticalChance = Math.max(0.05, 0.15 - dist * 0.005); // 5-15% chance based on distance
          const isCritical = Math.random() < criticalChance;
          
          const finalDamage = isCritical ? Math.floor(damage * 2) : damage;
          enemy.health -= finalDamage;
          
          // Create enhanced hit effect
          this.createHitEffect(enemy.x, enemy.y, isCritical);
          
          // Show damage number with critical styling
          this.showDamageNumber(enemy.x, enemy.y, finalDamage, isCritical);
          
          // Update round stats for hit and damage
          this.updateRoundStats('hit');
          this.updateRoundStats('damage', finalDamage);
          
          if (enemy.health <= 0) {
            enemy.alive = false;
            this.localPlayer.kills++;
            
            // Update round stats for kill
            this.updateRoundStats('kill');
            
            // Add kill feed entry
            const currentWeapon = this.getCurrentWeapon();
            const weaponName = currentWeapon ? currentWeapon.name : 'Unknown';
            this.addKillFeedEntry(
              this.localPlayer.name, 
              enemy.name || 'Enemy', 
              weaponName, 
              isCritical
            );
            
            // Create death effect
            this.createDeathEffect(enemy.x, enemy.y, enemy.name || 'Enemy');
            
            // Award kill money based on weapon type
            this.awardKillMoney(bullet.weaponType, enemy.team);
            
            // Drop weapon if enemy had primary weapon
            if (Math.random() > 0.3) { // 70% chance to drop weapon
              const enemyWeapon = this.getRandomEnemyWeapon();
              if (enemyWeapon) {
                this.gameState.weaponDrops.push({
                  id: 'enemy-drop-' + Date.now(),
                  weapon: enemyWeapon,
                  x: enemy.x,
                  y: enemy.y,
                  time: Date.now()
                });
              }
            }
          }
          return false; // Bullet stops after hitting
        }
      }
    }
    
    return bullet.life > 0;
  });
}

takeDamage(damage) {
  if (this.localPlayer.armor > 0) {
    const absorbed = Math.min(damage * 0.5, this.localPlayer.armor);
    this.localPlayer.armor -= absorbed;
    damage -= absorbed * 0.5;
  }
  
  this.localPlayer.health = Math.max(0, this.localPlayer.health - damage);
  this.updateHealthArmor();
  
  // Add damage feedback effects
  if (damage > 0) {
    // Screen flash effect - intensity based on damage
    const flashIntensity = Math.min(damage / 50, 1); // Cap at 50 damage
    const flashColor = `rgba(255, 50, 50, ${flashIntensity * 0.4})`;
    this.createScreenFlash(flashColor, 300);
    
    // Screen shake for heavy damage
    if (damage > 25) {
      this.weaponSystem.screenShake = {
        x: (Math.random() - 0.5) * (damage * 0.5),
        y: (Math.random() - 0.5) * (damage * 0.5),
        intensity: damage * 0.5,
        decay: 0.85
      };
    }
  }
  
  if (this.localPlayer.health <= 0) {
    this.localPlayer.alive = false;
    
    // Stronger death screen flash
    this.createScreenFlash('rgba(255, 0, 0, 0.8)', 1000);
    
    // Drop weapon on death
    const currentWeapon = this.getCurrentWeapon();
    if (currentWeapon && this.localPlayer.currentWeapon === 'primary') {
      this.gameState.weaponDrops.push({
        id: 'player-death-drop-' + Date.now(),
        weapon: { ...currentWeapon },
        x: this.localPlayer.x,
        y: this.localPlayer.y,
        time: Date.now()
      });
    }
    
    document.getElementById('death-screen').style.display = 'flex';
  }
}

updateHealthArmor() {
  document.getElementById('health-bar').style.width = this.localPlayer.health + '%';
  document.querySelector('.health-fill').parentElement.querySelector('.bar-text').textContent = this.localPlayer.health + ' HP';
  
  document.getElementById('armor-bar').style.width = this.localPlayer.armor + '%';
  document.querySelector('.armor-fill').parentElement.querySelector('.bar-text').textContent = this.localPlayer.armor + ' Armor';
}

updateAmmoDisplay() {
  document.getElementById('ammo-clip').textContent = this.localPlayer.weapon.ammo.clip;
  document.getElementById('ammo-reserve').textContent = this.localPlayer.weapon.ammo.reserve;
}

updateAutoAim() {
  // Auto-aim assistance - only works when actively enabled
  if (!this.autoAim || !this.localPlayer.alive) return;
  
  let closest = null;
  let minDist = Infinity;
  
  this.enemies.forEach(enemy => {
    if (!enemy.alive) return;
    const dist = Math.hypot(enemy.x - this.localPlayer.x, enemy.y - this.localPlayer.y);
    if (dist < minDist && dist < 400) {
      minDist = dist;
      closest = enemy;
    }
  });
  
  if (closest) {
    const targetAngle = Math.atan2(closest.y - this.localPlayer.y, closest.x - this.localPlayer.x);
    const diff = targetAngle - this.aimAngle;
    this.aimAngle += diff * 0.1;
  }
}

endRound(winner) {
  if (winner === 'ct') {
    this.gameState.ctScore++;
  } else {
    this.gameState.tScore++;
  }
  
  document.getElementById('ct-score-value').textContent = this.gameState.ctScore;
  document.getElementById('t-score-value').textContent = this.gameState.tScore;
  
  // 重置回合
  setTimeout(() => {
    this.resetRound();
  }, 3000);
}

resetRound() {
  this.gameState.roundNumber++;
  this.gameState.phase = 'buy';
  this.gameState.roundTime = 115;
  this.gameState.bombPlanted = false;
  
  // 復活玩家 using tactical spawn points
  this.localPlayer.health = 100;
  this.localPlayer.alive = true;
  const playerSpawn = this.getRandomSpawnPoint(this.localPlayer.team);
  this.localPlayer.x = playerSpawn.x;
  this.localPlayer.y = playerSpawn.y;
  
  // 復活敵人 using tactical spawn points
  this.enemies.forEach((enemy, i) => {
    enemy.alive = true;
    enemy.health = 100;
    const enemySpawn = this.getRandomSpawnPoint(enemy.team);
    enemy.x = enemySpawn.x;
    enemy.y = enemySpawn.y;
    enemy.hasLineOfSight = false;
    enemy.lastSeenPlayer = 0;
  });
  
  // 清空子彈
  this.gameState.bullets = [];
  
  // 更新 UI
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('bomb-indicator').style.display = 'none';
  document.getElementById('round-number').textContent = this.gameState.roundNumber;
  this.updateHealthArmor();
  
  // 15秒後進入戰鬥階段
  setTimeout(() => {
    this.gameState.phase = 'playing';
    document.getElementById('round-phase').textContent = 'Round Live';
    this.showNotification('Round started!');
  }, 15000);
}

render() {
  // 清空畫布
  this.ctx.fillStyle = '#2a2a2a';
  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  
  // Enhanced camera system with smooth transitions
  this.ctx.save();
  this.updateCameraSystem();
  
  const cameraX = this.canvas.width / 2 - this.gameState.camera.x + this.weaponSystem.screenShake.x;
  const cameraY = this.canvas.height / 2 - this.gameState.camera.y + this.weaponSystem.screenShake.y;
  
  this.ctx.translate(cameraX, cameraY);
  
  // 繪製地圖
  this.renderMap();
  
  // 繪製炸彈點
  this.renderBombSites();
  
  // 繪製玩家和敵人
  this.renderEntities();
  
  // 繪製子彈
  this.renderBullets();
  
  // 繪製武器掉落
  this.renderWeaponDrops();
  
  // 繪製炸彈
  if (this.gameState.bombPlanted) {
    this.renderBomb();
  }
  
  // 繪製視覺效果 (muzzle flash, bullet impacts, etc.)
  this.renderVisualEffects();
  
  // 繪製彈孔效果
  this.renderBulletHoles();
  
  this.ctx.restore();
  
  // 繪製準心（不受相機影響）
  this.renderCrosshair();
  
  // Show spectator info when dead
  if (!this.localPlayer.alive) {
    this.renderSpectatorInfo();
  }
  
  // Debug: Show player position and weapon stats
  this.ctx.fillStyle = 'white';
  this.ctx.font = '14px monospace';
  this.ctx.fillText(`Position: X:${Math.round(this.localPlayer.x)} Y:${Math.round(this.localPlayer.y)}`, 10, 30);
  this.ctx.fillText(`Keys pressed: ${Object.keys(this.keys).filter(k => this.keys[k]).join(', ')}`, 10, 50);
  this.ctx.fillText(`Team: ${this.localPlayer.team.toUpperCase()} | Health: ${this.localPlayer.health}`, 10, 70);
  this.ctx.fillText(`Mouse: X:${Math.round(this.mouseX)} Y:${Math.round(this.mouseY)} | Angle: ${(this.aimAngle * 180 / Math.PI).toFixed(1)}°`, 10, 90);
  
  // Weapon recoil debug info
  const currentWeapon = this.getCurrentWeapon();
  if (currentWeapon && this.weaponSystem.recoilStep > 0) {
    this.ctx.fillStyle = '#ffaa00';
    this.ctx.fillText(`Recoil: X:${this.weaponSystem.currentRecoil.x.toFixed(1)} Y:${this.weaponSystem.currentRecoil.y.toFixed(1)} Step:${this.weaponSystem.recoilStep}`, 10, 110);
    
    // Show accuracy
    const isMoving = this.weaponSystem.isMoving;
    const accuracy = isMoving ? currentWeapon.accuracy.moving : currentWeapon.accuracy.standing;
    const accuracyPercent = (accuracy * 100).toFixed(0);
    this.ctx.fillText(`Accuracy: ${accuracyPercent}% ${isMoving ? '(Moving)' : '(Standing)'}`, 10, 130);
  }
  
  // Render minimap (not affected by camera)
  this.renderMinimap();
  
  // Render sound range indicators
  this.renderSoundRanges();
  
  // Render screen flash effects (damage feedback, etc.)
  this.renderScreenFlash();
}

renderMap() {
  // Draw spawn zones (for debugging)
  this.ctx.fillStyle = 'rgba(100, 100, 255, 0.1)';  // CT spawn zone (blue)
  this.ctx.fillRect(150, 50, 700, 100);
  this.ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
  this.ctx.strokeRect(150, 50, 700, 100);
  this.ctx.fillStyle = 'rgba(100, 100, 255, 0.6)';
  this.ctx.font = '12px Arial';
  this.ctx.fillText('CT SPAWN', 450, 100);
  
  this.ctx.fillStyle = 'rgba(255, 100, 100, 0.1)';  // T spawn zone (red)
  this.ctx.fillRect(700, 700, 700, 100);
  this.ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
  this.ctx.strokeRect(700, 700, 700, 100);
  this.ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
  this.ctx.fillText('T SPAWN', 1000, 750);
  
  // 繪製牆壁
  this.ctx.fillStyle = '#444';
  this.gameState.map.walls.forEach(wall => {
    this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
  });
}

renderBombSites() {
  this.ctx.strokeStyle = '#ffaa00';
  this.ctx.lineWidth = 2;
  this.ctx.setLineDash([5, 5]);
  
  this.gameState.map.bombSites.forEach(site => {
    this.ctx.beginPath();
    this.ctx.arc(site.x, site.y, site.radius, 0, Math.PI * 2);
    this.ctx.stroke();
    
    this.ctx.fillStyle = '#ffaa00';
    this.ctx.font = 'bold 24px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText(site.name, site.x, site.y);
  });
  
  this.ctx.setLineDash([]);
}

renderBomb() {
  const site = this.gameState.bombSite;
  if (!site) return;
  
  // 炸彈閃爍效果
  const flash = Math.sin(Date.now() * 0.01) > 0;
  this.ctx.fillStyle = flash ? '#ff0000' : '#aa0000';
  this.ctx.beginPath();
  this.ctx.arc(site.x, site.y, 10, 0, Math.PI * 2);
  this.ctx.fill();
  
  if (this.gameState.bombTimer < 10) {
    this.ctx.strokeStyle = '#ff0000';
    this.ctx.lineWidth = 3;
    this.ctx.beginPath();
    this.ctx.arc(site.x, site.y, 20 + Math.sin(Date.now() * 0.02) * 5, 0, Math.PI * 2);
    this.ctx.stroke();
  }
}

renderEntities() {
  // 繪製敵人
  this.enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    this.ctx.fillStyle = enemy.team === 'ct' ? '#4488ff' : '#ff8844';
    this.ctx.beginPath();
    this.ctx.arc(enemy.x, enemy.y, 15, 0, Math.PI * 2);
    this.ctx.fill();
    
    // 方向指示
    this.ctx.strokeStyle = '#ffffff';
    this.ctx.lineWidth = 3;
    this.ctx.beginPath();
    this.ctx.moveTo(enemy.x, enemy.y);
    this.ctx.lineTo(
      enemy.x + Math.cos(enemy.angle) * 20,
      enemy.y + Math.sin(enemy.angle) * 20
    );
    this.ctx.stroke();
    
    // 血條
    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
    this.ctx.fillRect(enemy.x - 15, enemy.y - 25, 30, 4);
    this.ctx.fillStyle = enemy.health > 50 ? '#00ff00' : '#ff0000';
    this.ctx.fillRect(enemy.x - 15, enemy.y - 25, 30 * (enemy.health / 100), 4);
  });
  
  // 繪製本地玩家
  if (this.localPlayer.alive) {
    this.ctx.fillStyle = this.localPlayer.team === 'ct' ? '#4488ff' : '#ff8844';
    this.ctx.beginPath();
    this.ctx.arc(this.localPlayer.x, this.localPlayer.y, 15, 0, Math.PI * 2);
    this.ctx.fill();
    
    // 方向指示
    this.ctx.strokeStyle = '#ffffff';
    this.ctx.lineWidth = 3;
    this.ctx.beginPath();
    this.ctx.moveTo(this.localPlayer.x, this.localPlayer.y);
    this.ctx.lineTo(
      this.localPlayer.x + Math.cos(this.aimAngle) * 25,
      this.localPlayer.y + Math.sin(this.aimAngle) * 25
    );
    this.ctx.stroke();
  }
}

renderBullets() {
  this.gameState.bullets.forEach(bullet => {
    if (bullet.isTracer) {
      // Render tracer round with trail
      this.ctx.strokeStyle = '#ffff44';
      this.ctx.lineWidth = 2;
      this.ctx.shadowBlur = 3;
      this.ctx.shadowColor = '#ffff44';
      
      // Draw tracer trail
      const trailLength = 40;
      const trailX = bullet.x - (bullet.vx / Math.hypot(bullet.vx, bullet.vy)) * trailLength;
      const trailY = bullet.y - (bullet.vy / Math.hypot(bullet.vx, bullet.vy)) * trailLength;
      
      this.ctx.beginPath();
      this.ctx.moveTo(trailX, trailY);
      this.ctx.lineTo(bullet.x, bullet.y);
      this.ctx.stroke();
    }
    
    // Regular bullet
    this.ctx.fillStyle = bullet.isTracer ? '#ffff00' : '#ffffcc';
    this.ctx.shadowBlur = bullet.isTracer ? 5 : 2;
    this.ctx.shadowColor = bullet.isTracer ? '#ffff00' : '#ffffcc';
    
    this.ctx.beginPath();
    this.ctx.arc(bullet.x, bullet.y, bullet.isTracer ? 4 : 2, 0, Math.PI * 2);
    this.ctx.fill();
  });
  
  this.ctx.shadowBlur = 0;
}

renderWeaponDrops() {
  this.gameState.weaponDrops.forEach(drop => {
    // Draw weapon icon on ground
    const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
    
    this.ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    this.ctx.lineWidth = 2;
    
    // Draw weapon box
    this.ctx.fillRect(drop.x - 15, drop.y - 8, 30, 16);
    this.ctx.strokeRect(drop.x - 15, drop.y - 8, 30, 16);
    
    // Draw weapon name
    this.ctx.fillStyle = 'black';
    this.ctx.font = '10px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText(drop.weapon.name.substring(0, 6), drop.x, drop.y + 3);
  });
}

// Render all visual effects (muzzle flash, impacts, particles, damage numbers, blood splatter, explosions)
renderVisualEffects() {
  if (!this.gameState.visualEffects) return;
  
  const now = Date.now();
  
  this.gameState.visualEffects.forEach(effect => {
    const age = now - effect.startTime;
    const progress = age / effect.duration;
    const alpha = Math.max(0, 1 - progress);
    
    if (effect.type === 'damage') {
      // Render floating damage numbers with improved styling
      this.ctx.save();
      const floatY = effect.y - (progress * 40); // Float upward
      const scale = 1 + (0.3 * (1 - progress)); // Start larger, shrink
      
      this.ctx.fillStyle = effect.isCritical ? `rgba(255, 100, 100, ${alpha})` : `rgba(255, 255, 255, ${alpha})`;
      this.ctx.font = `bold ${Math.floor(16 * scale)}px Arial`;
      this.ctx.textAlign = 'center';
      this.ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
      this.ctx.lineWidth = 2;
      this.ctx.strokeText(effect.damage.toString(), effect.x, floatY);
      this.ctx.fillText(effect.damage.toString(), effect.x, floatY);
      this.ctx.restore();
      
    } else if (effect.type === 'blood') {
      // Render blood splatter effect
      effect.particles.forEach(particle => {
        const particleAlpha = (particle.life / particle.maxLife) * alpha;
        this.ctx.save();
        this.ctx.globalAlpha = particleAlpha;
        this.ctx.fillStyle = particle.color;
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Add blood trails for larger particles
        if (particle.size > 2) {
          this.ctx.strokeStyle = particle.color;
          this.ctx.lineWidth = particle.size * 0.5;
          this.ctx.lineCap = 'round';
          this.ctx.beginPath();
          this.ctx.moveTo(particle.x - particle.vx * 2, particle.y - particle.vy * 2);
          this.ctx.lineTo(particle.x, particle.y);
          this.ctx.stroke();
        }
        this.ctx.restore();
      });
      
    } else if (effect.type === 'explosion') {
      // Render explosion effect with multiple layers
      this.ctx.save();
      this.ctx.translate(effect.x, effect.y);
      
      const explosionSize = effect.size * (1 + progress * 2);
      const innerSize = explosionSize * 0.6;
      
      // Outer ring (smoke/debris)
      this.ctx.fillStyle = `rgba(80, 60, 40, ${alpha * 0.7})`;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, explosionSize, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Fire layer
      this.ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, innerSize, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Hot center
      this.ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, innerSize * 0.5, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Particles
      effect.particles.forEach(particle => {
        const particleAlpha = (particle.life / particle.maxLife) * alpha;
        this.ctx.fillStyle = particle.color.replace(')', `, ${particleAlpha})`).replace('rgb', 'rgba');
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        this.ctx.fill();
      });
      
      this.ctx.restore();
      
    } else if (effect.particles) {
      // Render enhanced particle effects (sparks, dust, debris)
      effect.particles.forEach(particle => {
        const particleAlpha = (particle.life / particle.maxLife) * alpha;
        this.ctx.save();
        this.ctx.globalAlpha = particleAlpha;
        
        if (particle.type === 'spark') {
          // Render sparks with trailing effect
          this.ctx.strokeStyle = particle.color;
          this.ctx.lineWidth = particle.size;
          this.ctx.lineCap = 'round';
          this.ctx.beginPath();
          this.ctx.moveTo(particle.x - particle.vx * 3, particle.y - particle.vy * 3);
          this.ctx.lineTo(particle.x, particle.y);
          this.ctx.stroke();
          
          // Add glow to sparks
          this.ctx.shadowColor = particle.color;
          this.ctx.shadowBlur = particle.size * 2;
          this.ctx.fillStyle = particle.color;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);
          this.ctx.fill();
        } else {
          // Regular particles (dust, debris)
          this.ctx.fillStyle = particle.color;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
        }
        this.ctx.restore();
      });
    }
  });
  
  // Render enhanced muzzle flash with bloom effect
  if (this.weaponSystem.muzzleFlash.active && this.localPlayer.alive) {
    const flash = this.weaponSystem.muzzleFlash;
    const flashAge = now - flash.startTime;
    const flashAlpha = Math.max(0, 1 - (flashAge / flash.duration));
    
    if (flashAlpha > 0) {
      this.ctx.save();
      this.ctx.translate(flash.x, flash.y);
      this.ctx.rotate(flash.angle);
      
      // Create bloom effect with multiple layers
      const bloomLayers = [
        { size: 60, alpha: 0.15, color: [255, 150, 0] },
        { size: 40, alpha: 0.25, color: [255, 180, 0] },
        { size: 25, alpha: 0.4, color: [255, 200, 0] },
        { size: 15, alpha: 0.8, color: [255, 255, 255] }
      ];
      
      bloomLayers.forEach(layer => {
        this.ctx.shadowColor = `rgba(${layer.color.join(',')}, ${layer.alpha * flashAlpha})`;
        this.ctx.shadowBlur = layer.size;
        this.ctx.fillStyle = `rgba(${layer.color.join(',')}, ${layer.alpha * flashAlpha})`;
        this.ctx.fillRect(-layer.size/3, -layer.size/6, layer.size*2/3, layer.size/3);
      });
      
      // Add random flicker pattern
      const flicker = 0.8 + Math.random() * 0.4;
      
      // Main flash body
      this.ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
      this.ctx.shadowBlur = 30;
      this.ctx.fillStyle = `rgba(255, 200, 0, ${flashAlpha * 0.9 * flicker})`;
      this.ctx.fillRect(-25, -10, 50, 20);
      
      // Bright white center
      this.ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * flicker})`;
      this.ctx.fillRect(-18, -6, 36, 12);
      
      // Add muzzle flash particles
      for (let i = 0; i < 5; i++) {
        const angle = (Math.PI / 6) * (i - 2) + (Math.random() - 0.5) * 0.5;
        const distance = 20 + Math.random() * 15;
        const px = Math.cos(angle) * distance;
        const py = Math.sin(angle) * distance;
        
        this.ctx.fillStyle = `rgba(255, 150, 0, ${flashAlpha * 0.6 * flicker})`;
        this.ctx.beginPath();
        this.ctx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
        this.ctx.fill();
      }
      
      this.ctx.restore();
    }
  }
  
  // Render hit markers
  this.renderHitMarkers();
}

switchSpectatorTarget(keyNumber) {
  if (this.localPlayer.alive) return;
  
  // Key 1-5 switches between enemies (simulate teammates)
  const aliveEnemies = this.enemies.filter(e => e.alive);
  if (keyNumber <= aliveEnemies.length) {
    const target = aliveEnemies[keyNumber - 1];
    this.gameState.spectatorMode = 'follow';
    this.gameState.spectatingPlayer = target;
    document.getElementById('spectating-player').textContent = target.name || `Bot${keyNumber}`;
  } else {
    // Switch back to free look
    this.gameState.spectatorMode = 'free';
    this.gameState.spectatingPlayer = null;
    document.getElementById('spectating-player').textContent = 'Free Look';
  }
}

updateSpectatorCamera() {
  if (this.localPlayer.alive) return;
  
  // Allow mouse movement to control spectator camera in free look mode
  if (this.gameState.spectatorMode === 'free') {
    const sensitivity = 2;
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    const deltaX = (this.mouseX - centerX) * sensitivity;
    const deltaY = (this.mouseY - centerY) * sensitivity;
    
    this.gameState.spectatorCamera.x += deltaX * 0.01;
    this.gameState.spectatorCamera.y += deltaY * 0.01;
    
    // Clamp to map boundaries
    this.gameState.spectatorCamera.x = Math.max(100, Math.min(1500, this.gameState.spectatorCamera.x));
    this.gameState.spectatorCamera.y = Math.max(100, Math.min(800, this.gameState.spectatorCamera.y));
  }
}

renderSpectatorInfo() {
  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
  this.ctx.fillRect(10, this.canvas.height - 100, 300, 80);
  
  this.ctx.fillStyle = 'white';
  this.ctx.font = '16px Arial';
  this.ctx.fillText('SPECTATOR MODE', 20, this.canvas.height - 75);
  
  this.ctx.font = '12px Arial';
  if (this.gameState.spectatorMode === 'follow' && this.gameState.spectatingPlayer) {
    this.ctx.fillText(`Following: ${this.gameState.spectatingPlayer.name || 'Bot'}`, 20, this.canvas.height - 55);
    this.ctx.fillText(`Health: ${this.gameState.spectatingPlayer.health}`, 20, this.canvas.height - 40);
  } else {
    this.ctx.fillText('Free Look Mode', 20, this.canvas.height - 55);
  }
  
  this.ctx.fillStyle = '#aaa';
  this.ctx.fillText('Press 1-5 to follow teammates', 20, this.canvas.height - 25);
}

renderCrosshair() {
  if (!this.localPlayer.alive) return; // No crosshair when dead
  
  // Draw crosshair at mouse position
  const crosshairColor = this.autoAim ? '#ff9999' : '#99ff99';
  this.ctx.strokeStyle = crosshairColor;
  this.ctx.lineWidth = 2;
  
  // Draw crosshair at mouse position
  this.ctx.beginPath();
  this.ctx.moveTo(this.mouseX - 15, this.mouseY);
  this.ctx.lineTo(this.mouseX - 5, this.mouseY);
  this.ctx.moveTo(this.mouseX + 5, this.mouseY);
  this.ctx.lineTo(this.mouseX + 15, this.mouseY);
  this.ctx.moveTo(this.mouseX, this.mouseY - 15);
  this.ctx.lineTo(this.mouseX, this.mouseY - 5);
  this.ctx.moveTo(this.mouseX, this.mouseY + 5);
  this.ctx.lineTo(this.mouseX, this.mouseY + 15);
  this.ctx.stroke();
  
  // Draw aim line from player to mouse (optional visual aid)
  const centerX = this.canvas.width / 2;
  const centerY = this.canvas.height / 2;
  
  this.ctx.strokeStyle = this.autoAim ? 'rgba(255,100,100,0.2)' : 'rgba(100,255,100,0.2)';
  this.ctx.lineWidth = 1;
  this.ctx.setLineDash([5, 5]);
  this.ctx.beginPath();
  this.ctx.moveTo(centerX, centerY);
  this.ctx.lineTo(this.mouseX, this.mouseY);
  this.ctx.stroke();
  this.ctx.setLineDash([]);
}

renderMinimap() {
  if (!this.minimap.enabled) return;
  
  const mm = this.minimap;
  
  // Keep minimap in top-left corner as configured
  // mm.x and mm.y are set in setupMinimap()
  
  // Draw minimap background
  this.ctx.fillStyle = mm.backgroundColor;
  this.ctx.fillRect(mm.x, mm.y, mm.size, mm.size);
  
  // Draw minimap border
  this.ctx.strokeStyle = mm.borderColor;
  this.ctx.lineWidth = 2;
  this.ctx.strokeRect(mm.x, mm.y, mm.size, mm.size);
  
  // Save context for minimap rendering
  this.ctx.save();
  this.ctx.beginPath();
  this.ctx.rect(mm.x, mm.y, mm.size, mm.size);
  this.ctx.clip();
  
  // Draw map walls on minimap
  this.ctx.fillStyle = mm.wallColor;
  this.gameState.map.walls.forEach(wall => {
    const mmX = mm.x + (wall.x * mm.scale);
    const mmY = mm.y + (wall.y * mm.scale);
    const mmW = wall.width * mm.scale;
    const mmH = wall.height * mm.scale;
    this.ctx.fillRect(mmX, mmY, mmW, mmH);
  });
  
  // Draw bomb sites on minimap
  this.ctx.strokeStyle = mm.bombSiteColor;
  this.ctx.lineWidth = 1;
  this.gameState.map.bombSites.forEach(site => {
    const mmX = mm.x + (site.x * mm.scale);
    const mmY = mm.y + (site.y * mm.scale);
    const mmR = site.radius * mm.scale;
    
    this.ctx.fillStyle = mm.bombSiteColor;
    this.ctx.beginPath();
    this.ctx.arc(mmX, mmY, mmR, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw site letter
    this.ctx.fillStyle = 'white';
    this.ctx.font = 'bold 10px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText(site.name, mmX, mmY + 3);
  });
  
  // Draw enemies on minimap
  this.enemies.forEach(enemy => {
    const mmX = mm.x + (enemy.x * mm.scale);
    const mmY = mm.y + (enemy.y * mm.scale);
    
    if (enemy.alive) {
      // Draw alive enemy as dot
      this.ctx.fillStyle = enemy.team === 'ct' ? mm.ctColor : mm.tColor;
      this.ctx.beginPath();
      this.ctx.arc(mmX, mmY, mm.playerDotSize, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Draw direction indicator
      this.ctx.strokeStyle = 'white';
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(mmX, mmY);
      this.ctx.lineTo(
        mmX + Math.cos(enemy.angle) * (mm.playerDotSize + 2),
        mmY + Math.sin(enemy.angle) * (mm.playerDotSize + 2)
      );
      this.ctx.stroke();
    } else {
      // Draw dead enemy as X mark
      this.ctx.strokeStyle = mm.deadPlayerColor;
      this.ctx.lineWidth = 2;
      const markSize = mm.deadPlayerMarkSize / 2;
      
      // Draw X
      this.ctx.beginPath();
      this.ctx.moveTo(mmX - markSize, mmY - markSize);
      this.ctx.lineTo(mmX + markSize, mmY + markSize);
      this.ctx.moveTo(mmX + markSize, mmY - markSize);
      this.ctx.lineTo(mmX - markSize, mmY + markSize);
      this.ctx.stroke();
    }
  });
  
  // Draw local player on minimap
  const mmX = mm.x + (this.localPlayer.x * mm.scale);
  const mmY = mm.y + (this.localPlayer.y * mm.scale);
  
  if (this.localPlayer.alive) {
    // Player dot with outline
    this.ctx.fillStyle = this.localPlayer.team === 'ct' ? mm.ctColor : mm.tColor;
    this.ctx.strokeStyle = 'white';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.arc(mmX, mmY, mm.playerDotSize + 1, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw view cone/aim direction
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(mmX, mmY);
    this.ctx.lineTo(
      mmX + Math.cos(this.aimAngle) * (mm.playerDotSize + 5),
      mmY + Math.sin(this.aimAngle) * (mm.playerDotSize + 5)
    );
    this.ctx.stroke();
  } else {
    // Draw dead local player as X mark with white outline
    this.ctx.strokeStyle = 'white';
    this.ctx.lineWidth = 3;
    const markSize = mm.deadPlayerMarkSize / 2;
    
    // Draw X with white outline
    this.ctx.beginPath();
    this.ctx.moveTo(mmX - markSize, mmY - markSize);
    this.ctx.lineTo(mmX + markSize, mmY + markSize);
    this.ctx.moveTo(mmX + markSize, mmY - markSize);
    this.ctx.lineTo(mmX - markSize, mmY + markSize);
    this.ctx.stroke();
    
    // Draw inner X with team color
    this.ctx.strokeStyle = this.localPlayer.team === 'ct' ? mm.ctColor : mm.tColor;
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(mmX - markSize, mmY - markSize);
    this.ctx.lineTo(mmX + markSize, mmY + markSize);
    this.ctx.moveTo(mmX + markSize, mmY - markSize);
    this.ctx.lineTo(mmX - markSize, mmY + markSize);
    this.ctx.stroke();
  }
  
  // Draw bomb if planted
  if (this.gameState.bombPlanted && this.gameState.bombSite) {
    const site = this.gameState.bombSite;
    const mmX = mm.x + (site.x * mm.scale);
    const mmY = mm.y + (site.y * mm.scale);
    
    // Flashing bomb indicator
    const flash = Math.sin(Date.now() * 0.01) > 0;
    this.ctx.fillStyle = flash ? '#ff0000' : '#aa0000';
    this.ctx.beginPath();
    this.ctx.arc(mmX, mmY, mm.playerDotSize, 0, Math.PI * 2);
    this.ctx.fill();
  }
  
  this.ctx.restore();
  
  // Draw minimap title
  this.ctx.fillStyle = 'white';
  this.ctx.font = 'bold 12px Arial';
  this.ctx.textAlign = 'center';
  this.ctx.fillText('RADAR', mm.x + mm.size/2, mm.y - 5);
  this.ctx.textAlign = 'left';
}

renderSoundRanges() {
  if (!this.localPlayer.alive) return;
  
  // Enhanced sound range indicators - now enabled for better gameplay feedback
  const showSoundRanges = true; // Enabled for tactical awareness
  const showSoundEvents = true; // Show when sounds are heard
  
  if (showSoundRanges) {
    // Save context and apply camera transform
    this.ctx.save();
    let cameraX = this.canvas.width / 2 - this.localPlayer.x;
    let cameraY = this.canvas.height / 2 - this.localPlayer.y;
    this.ctx.translate(cameraX, cameraY);
    
    // Draw footstep sound range (more visible)
    this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.15)';
    this.ctx.fillStyle = 'rgba(100, 255, 100, 0.05)';
    this.ctx.lineWidth = 2;
    this.ctx.setLineDash([10, 5]);
    this.ctx.beginPath();
    this.ctx.arc(this.localPlayer.x, this.localPlayer.y, this.gameState.map.soundRanges.footsteps, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw reload sound range
    this.ctx.strokeStyle = 'rgba(255, 255, 100, 0.15)';
    this.ctx.fillStyle = 'rgba(255, 255, 100, 0.03)';
    this.ctx.setLineDash([5, 10]);
    this.ctx.beginPath();
    this.ctx.arc(this.localPlayer.x, this.localPlayer.y, this.gameState.map.soundRanges.reload, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw gunshot sound range (largest)
    this.ctx.strokeStyle = 'rgba(255, 100, 100, 0.2)';
    this.ctx.fillStyle = 'rgba(255, 100, 100, 0.02)';
    this.ctx.setLineDash([15, 5]);
    this.ctx.beginPath();
    this.ctx.arc(this.localPlayer.x, this.localPlayer.y, this.gameState.map.soundRanges.gunshots, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    this.ctx.setLineDash([]);
    this.ctx.restore();
  }
  
  // Show sound event indicators when enemies make noise
  if (showSoundEvents) {
    this.ctx.save();
    let cameraX = this.canvas.width / 2 - this.localPlayer.x;
    let cameraY = this.canvas.height / 2 - this.localPlayer.y;
    this.ctx.translate(cameraX, cameraY);
    
    this.enemies.forEach(enemy => {
      if (!enemy.alive) return;
      
      // Check if player can hear this enemy
      const canHearFootsteps = this.canHearSound(enemy.x, enemy.y, this.localPlayer.x, this.localPlayer.y, 'footsteps');
      const canHearGunshots = enemy.lastShoot && (Date.now() - enemy.lastShoot < 1000) && 
                             this.canHearSound(enemy.x, enemy.y, this.localPlayer.x, this.localPlayer.y, 'gunshots');
      
      if (canHearFootsteps || canHearGunshots) {
        // Draw sound wave indicator
        const time = Date.now() * 0.005;
        const pulseSize = 20 + Math.sin(time) * 10;
        
        if (canHearGunshots) {
          // Gunshot sound - red pulse
          this.ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)';
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.arc(enemy.x, enemy.y, pulseSize + 10, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Add text indicator
          this.ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
          this.ctx.font = 'bold 12px Arial';
          this.ctx.textAlign = 'center';
          this.ctx.fillText('GUNFIRE', enemy.x, enemy.y - 40);
        } else if (canHearFootsteps) {
          // Footstep sound - green pulse
          this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.6)';
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.arc(enemy.x, enemy.y, pulseSize, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Add direction indicator
          const angle = Math.atan2(enemy.y - this.localPlayer.y, enemy.x - this.localPlayer.x);
          this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.4)';
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5, 5]);
          this.ctx.beginPath();
          this.ctx.moveTo(this.localPlayer.x, this.localPlayer.y);
          this.ctx.lineTo(
            this.localPlayer.x + Math.cos(angle) * 100,
            this.localPlayer.y + Math.sin(angle) * 100
          );
          this.ctx.stroke();
          this.ctx.setLineDash([]);
        }
      }
    });
    
    this.ctx.textAlign = 'left';
    this.ctx.restore();
  }
  
  // Visual indicator for nearby sounds
  this.enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    // Check if player can hear enemy footsteps
    if (this.canHearSound(enemy.x, enemy.y, this.localPlayer.x, this.localPlayer.y, 'footsteps')) {
      // Show audio cue indicator (not exact position)
      const angle = Math.atan2(enemy.y - this.localPlayer.y, enemy.x - this.localPlayer.x);
      const indicatorDistance = 100;
      const indicatorX = this.canvas.width / 2 + Math.cos(angle) * indicatorDistance;
      const indicatorY = this.canvas.height / 2 + Math.sin(angle) * indicatorDistance;
      
      // Draw subtle directional audio indicator
      this.ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
      this.ctx.beginPath();
      this.ctx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
      this.ctx.fill();
      
      this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(indicatorX, indicatorY, 8 + Math.sin(Date.now() * 0.01) * 3, 0, Math.PI * 2);
      this.ctx.stroke();
    }
  });
}

showNotification(text) {
  const div = document.createElement('div');
  div.className = 'notification';
  div.textContent = text;
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 2000);
}

showBombProgress(text, type) {
  const progressDiv = document.getElementById('bomb-progress');
  const textDiv = document.getElementById('bomb-action-text');
  const fillDiv = document.getElementById('bomb-progress-fill');
  
  textDiv.textContent = text;
  fillDiv.className = `progress-fill ${type}-fill`;
  progressDiv.style.display = 'block';
}

hideBombProgress() {
  document.getElementById('bomb-progress').style.display = 'none';
}

startRound() {
  this.gameState.phase = 'freeze';
  this.gameState.phaseTimer = 5;
  this.localPlayer.frozen = true;
  
  // Reset bomb state
  this.gameState.bombPlanted = false;
  this.gameState.bombAction = null;
  this.gameState.bombProgress = 0;
  document.getElementById('bomb-indicator').style.display = 'none';
  this.hideBombProgress();
  
  this.updateUI();
  this.showNotification('Round starting! Freeze time: 5 seconds');
}

startBuyPhase() {
  this.gameState.phase = 'buy';
  this.gameState.phaseTimer = 15;
  this.localPlayer.frozen = false;
  
  this.updateUI();
  this.showNotification('Buy time! 15 seconds to purchase equipment');
}

startPlayingPhase() {
  this.gameState.phase = 'playing';
  this.localPlayer.frozen = false;
  
  this.updateUI();
  this.showNotification('Round live! Go! Go! Go!');
}

awardRoundBonuses(winner, reason) {
  let bonus = 0;
  let message = '';
  
  if (winner === this.localPlayer.team) {
    // Win bonus
    bonus = this.ECONOMY.ROUND_WIN_REWARD;
    message = `Round win bonus: +$${bonus}`;
    
    // Extra bonus for bomb plant/defuse
    if (reason === 'bomb_defused' && this.localPlayer.team === 'ct') {
      bonus += this.ECONOMY.BOMB_DEFUSE_REWARD;
      message = `Round win + defuse bonus: +$${bonus}`;
    } else if (reason === 'bomb_exploded' && this.localPlayer.team === 't') {
      // T team already got plant bonus, just win bonus
    }
    
  } else {
    // Loss bonus - increases with consecutive losses
    const consecutiveLosses = this.localPlayer.team === 'ct' ? 
      this.gameState.economy.ctConsecutiveLosses : 
      this.gameState.economy.tConsecutiveLosses;
      
    bonus = Math.min(
      this.ECONOMY.ROUND_LOSS_BASE + (consecutiveLosses * this.ECONOMY.ROUND_LOSS_INCREMENT),
      this.ECONOMY.ROUND_LOSS_MAX
    );
    
    message = `Round loss bonus: +$${bonus}`;
    if (consecutiveLosses > 0) {
      message += ` (${consecutiveLosses + 1} consecutive losses)`;
    }
  }
  
  this.addMoney(bonus);
  this.showEconomyNotification(message, 'success');
}

endRound(winner, reason = '') {
  this.gameState.phase = 'ended';
  
  // Award round bonuses based on result
  this.awardRoundBonuses(winner, reason);
  
  if (winner === 'ct') {
    this.gameState.ctScore++;
    this.gameState.economy.ctConsecutiveLosses = 0;
    this.gameState.economy.tConsecutiveLosses++;
  } else if (winner === 't') {
    this.gameState.tScore++;
    this.gameState.economy.tConsecutiveLosses = 0;
    this.gameState.economy.ctConsecutiveLosses++;
  }
  
  this.gameState.economy.lastWinner = winner;
  
  document.getElementById('ct-score-value').textContent = this.gameState.ctScore;
  document.getElementById('t-score-value').textContent = this.gameState.tScore;
  
  let message = '';
  if (reason === 'bomb_defused') {
    message = 'Counter-Terrorists win - Bomb defused!';
  } else if (reason === 'bomb_exploded') {
    message = 'Terrorists win - Bomb exploded!';
  } else if (reason === 'time_up') {
    message = winner === 'ct' ? 'Counter-Terrorists win - Time expired!' : 'Terrorists win!';
  } else {
    message = `${winner.toUpperCase()} team wins!`;
  }
  
  this.showNotification(message);
  
  // Show round summary screen
  this.showRoundSummary(winner, reason);
  
  // Check for game over
  if (this.gameState.ctScore >= 16 || this.gameState.tScore >= 16 || this.gameState.roundNumber >= 30) {
    this.endGame();
  } else {
    // Start new round after 5 seconds
    setTimeout(() => {
      this.gameState.roundNumber++;
      this.resetRound();
      this.startRound();
    }, 5000);
  }
}

endGame() {
  const winner = this.gameState.ctScore > this.gameState.tScore ? 'Counter-Terrorists' : 'Terrorists';
  const isVictory = (winner === 'Counter-Terrorists' && this.localPlayer.team === 'ct') ||
                   (winner === 'Terrorists' && this.localPlayer.team === 't');
  
  // Enhanced end game screen
  this.showGameOverScreen(winner, isVictory, this.gameState.ctScore, this.gameState.tScore);
  
  this.gameState.phase = 'ended';
}

resetRound() {
  // Reset player state
  this.localPlayer.health = 100;
  this.localPlayer.alive = true;
  this.localPlayer.frozen = true;
  
  // Respawn player using tactical spawn points
  const spawnPoint = this.getRandomSpawnPoint(this.localPlayer.team);
  this.localPlayer.x = spawnPoint.x;
  this.localPlayer.y = spawnPoint.y;
  
  // Reset enhanced camera system
  this.resetCameraSystem();
  
  // Reset enemies using tactical spawn points
  this.enemies.forEach((enemy, i) => {
    enemy.alive = true;
    enemy.health = 100;
    const enemySpawn = this.getRandomSpawnPoint(enemy.team);
    enemy.x = enemySpawn.x;
    enemy.y = enemySpawn.y;
    enemy.hasLineOfSight = false;
    enemy.lastSeenPlayer = 0;
  });
  
  // Clear bullets
  this.gameState.bullets = [];
  
  // Update UI
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('spectator-ui').style.display = 'none';
  this.updateHealthArmor();
  this.updateUI();
}

updateMoneyDisplay() {
  document.getElementById('money').textContent = '$' + this.localPlayer.money;
}

updateUI() {
  // Update round info
  document.getElementById('round-number').textContent = this.gameState.roundNumber;
  
  // Update phase display
  const phaseDisplay = document.getElementById('round-phase');
  switch (this.gameState.phase) {
    case 'freeze':
      phaseDisplay.textContent = 'Freeze Time';
      phaseDisplay.style.color = '#ff6600';
      break;
    case 'buy':
      phaseDisplay.textContent = 'Buy Time';
      phaseDisplay.style.color = '#ffaa00';
      break;
    case 'playing':
      phaseDisplay.textContent = 'Round Live';
      phaseDisplay.style.color = '#00ff00';
      break;
    case 'ended':
      phaseDisplay.textContent = 'Round Ended';
      phaseDisplay.style.color = '#ff4444';
      break;
  }
}

// Economy System Functions
getCurrentWeapon() {
  return this.localPlayer.weapons[this.localPlayer.currentWeapon];
}

switchWeapon(slot) {
  if (!this.localPlayer.alive) return;
  
  if (slot === 'secondary' || (slot === 'primary' && this.localPlayer.weapons.primary)) {
    this.localPlayer.currentWeapon = slot;
    this.updateAmmoDisplay();
    this.updateWeaponDisplay();
    const weaponName = this.getCurrentWeapon()?.name || 'None';
    this.showNotification(`Switched to ${weaponName}`);
  }
}

updateWeaponDisplay() {
  const weaponNameElement = document.getElementById('weapon-name');
  if (!weaponNameElement) return;
  
  // Show switching animation if weapons are being switched
  if (this.weaponSystem.switchingWeapon) {
    const progress = (Date.now() - this.weaponSystem.switchStartTime) / 1000;
    const targetWeapon = this.localPlayer.weapons[this.localPlayer.currentWeapon === 'primary' ? 'secondary' : 'primary'];
    
    if (targetWeapon) {
      // Show transition animation
      const dots = '.'.repeat(Math.floor(progress * 3) % 4);
      weaponNameElement.textContent = `Switching to ${targetWeapon.name}${dots}`;
      weaponNameElement.style.color = '#ffaa00';
      return;
    }
  }
  
  // Show current weapon
  const currentWeapon = this.getCurrentWeapon();
  if (currentWeapon) {
    weaponNameElement.textContent = currentWeapon.name;
    weaponNameElement.style.color = '#ffffff';
    
    // Add weapon model indicator
    const modelIndicator = this.getWeaponModelIndicator(currentWeapon.model);
    if (modelIndicator) {
      weaponNameElement.textContent += ` ${modelIndicator}`;
    }
  } else {
    weaponNameElement.textContent = 'No Weapon';
    weaponNameElement.style.color = '#777777';
  }
}

// Get weapon model indicator/icon
getWeaponModelIndicator(model) {
  const indicators = {
    'usp': '🔫',
    'glock': '🔫',
    'deagle': '💥',
    'fiveseven': '🔫',
    'ak47': '🔥',
    'm4a1': '⚡',
    'awp': '🎯',
    'famas': '📡',
    'galil': '🔧'
  };
  
  return indicators[model] || '🔫';
}

switchBuyCategory(category) {
  // Remove active class from all tabs and categories
  document.querySelectorAll('.buy-tab').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.buy-category').forEach(cat => cat.classList.remove('active'));
  
  // Add active class to selected tab and category
  document.querySelector(`[data-category="${category}"]`).classList.add('active');
  document.getElementById(category).classList.add('active');
}

updateBuyMenu() {
  // Update money display in buy menu
  document.getElementById('buy-menu-money').textContent = '$' + this.localPlayer.money;
  
  // Update rebuy button
  const rebuyBtn = document.getElementById('rebuy-btn');
  rebuyBtn.disabled = this.gameState.purchaseHistory.length === 0;
  
  // Update buy items availability
  document.querySelectorAll('.buy-item').forEach(btn => {
    const price = parseInt(btn.dataset.price);
    const team = btn.dataset.team;
    const weapon = btn.dataset.weapon;
    
    // Check if player has enough money
    const hasEnoughMoney = this.localPlayer.money >= price;
    
    // Check team restrictions
    const teamAllowed = !team || team === this.localPlayer.team;
    
    // Check special restrictions
    let canBuy = true;
    if (weapon === 'helmet' && this.localPlayer.armor === 0) {
      canBuy = false; // Need kevlar first
    }
    
    const isEnabled = hasEnoughMoney && teamAllowed && canBuy;
    
    btn.classList.toggle('disabled', !isEnabled);
    btn.classList.toggle('insufficient', !hasEnoughMoney);
    
    if (!teamAllowed) {
      btn.style.display = 'none';
    } else {
      btn.style.display = 'flex';
    }
  });
}

buyWeapon(weaponId, price, type, team) {
  // Check buy phase
  if (this.gameState.phase !== 'buy' && 
      !(this.gameState.phase === 'playing' && this.gameState.roundTime > 100)) {
    this.showEconomyNotification('Can only buy during buy time!', 'warning');
    return;
  }
  
  // Check money
  if (this.localPlayer.money < price) {
    this.showEconomyNotification(`Not enough money! Need $${price}`, 'error');
    return;
  }
  
  // Check team restrictions
  if (team && team !== this.localPlayer.team) {
    this.showEconomyNotification('Your team cannot buy this weapon!', 'error');
    return;
  }
  
  // Special checks
  if (weaponId === 'helmet' && this.localPlayer.armor === 0) {
    this.showEconomyNotification('Need Kevlar vest first!', 'error');
    return;
  }
  
  // Process purchase
  this.localPlayer.money = Math.max(0, this.localPlayer.money - price);
  
  const weaponData = this.ECONOMY.WEAPONS[weaponId];
  if (!weaponData) return;
  
  if (type === 'pistol') {
    this.localPlayer.weapons.secondary = { ...weaponData };
    this.localPlayer.currentWeapon = 'secondary';
  } else if (type === 'rifle') {
    this.localPlayer.weapons.primary = { ...weaponData };
    this.localPlayer.currentWeapon = 'primary';
  } else if (type === 'equipment') {
    this.handleEquipmentPurchase(weaponId, weaponData);
  }
  
  // Record purchase for rebuy
  this.gameState.purchaseHistory.push({ weaponId, price, type, team });
  if (this.gameState.purchaseHistory.length > 10) {
    this.gameState.purchaseHistory.shift(); // Keep only last 10 purchases
  }
  
  this.updateMoneyDisplay();
  this.updateAmmoDisplay();
  this.updateWeaponDisplay();
  this.updateHealthArmor();
  
  this.showEconomyNotification(`Purchased: ${weaponData.name} (-$${price})`, 'success');
  
  // Auto-close buy menu after purchase
  setTimeout(() => {
    document.getElementById('buy-menu').style.display = 'none';
  }, 1000);
}

handleEquipmentPurchase(weaponId, weaponData) {
  switch (weaponId) {
    case 'kevlar':
      this.localPlayer.armor = 100;
      break;
    case 'helmet':
      this.localPlayer.hasHelmet = true;
      break;
    case 'defuse':
      this.localPlayer.hasDefuseKit = true;
      break;
    // Add grenade handling here if needed
  }
}

rebuyLastPurchase() {
  if (this.gameState.purchaseHistory.length === 0) {
    this.showEconomyNotification('No previous purchases!', 'warning');
    return;
  }
  
  // Get the last few purchases and try to buy them
  const recentPurchases = this.gameState.purchaseHistory.slice(-3);
  let totalCost = 0;
  let purchaseItems = [];
  
  for (const purchase of recentPurchases) {
    totalCost += purchase.price;
    purchaseItems.push(purchase);
  }
  
  if (this.localPlayer.money < totalCost) {
    this.showEconomyNotification(`Insufficient funds for rebuy! Need $${totalCost}`, 'error');
    return;
  }
  
  // Execute rebuy
  for (const purchase of purchaseItems) {
    this.buyWeapon(purchase.weaponId, purchase.price, purchase.type, purchase.team);
  }
  
  this.showEconomyNotification(`Rebuy completed! Total: $${totalCost}`, 'success');
}

dropCurrentWeapon() {
  if (!this.localPlayer.alive || this.gameState.bombAction) return;
  
  const currentWeapon = this.getCurrentWeapon();
  if (!currentWeapon || this.localPlayer.currentWeapon === 'secondary') {
    this.showNotification('Cannot drop this weapon!');
    return;
  }
  
  // Create weapon drop
  this.gameState.weaponDrops.push({
    id: 'drop-' + Date.now(),
    weapon: { ...currentWeapon },
    x: this.localPlayer.x,
    y: this.localPlayer.y,
    time: Date.now()
  });
  
  // Remove weapon from player
  this.localPlayer.weapons.primary = null;
  this.localPlayer.currentWeapon = 'secondary';
  
  this.updateAmmoDisplay();
  this.updateWeaponDisplay();
  this.showNotification('Weapon dropped!');
}

checkWeaponPickup() {
  if (!this.localPlayer.alive) return;
  
  let nearbyWeapon = null;
  let minDistance = Infinity;
  
  this.gameState.weaponDrops.forEach(drop => {
    const distance = Math.hypot(
      this.localPlayer.x - drop.x,
      this.localPlayer.y - drop.y
    );
    
    if (distance < 50 && distance < minDistance) {
      minDistance = distance;
      nearbyWeapon = drop;
    }
  });
  
  const indicator = document.getElementById('weapon-drop-indicator');
  if (nearbyWeapon) {
    indicator.style.display = 'block';
    indicator.innerHTML = `Press E to pick up ${nearbyWeapon.weapon.name}`;
    return nearbyWeapon;
  } else {
    indicator.style.display = 'none';
    return null;
  }
}

pickupWeapon(weaponDrop) {
  if (!weaponDrop) return;
  
  // If player has primary weapon, drop it first
  if (this.localPlayer.weapons.primary) {
    this.dropCurrentWeapon();
  }
  
  // Pick up the new weapon
  this.localPlayer.weapons.primary = { ...weaponDrop.weapon };
  this.localPlayer.currentWeapon = 'primary';
  
  // Remove from ground
  this.gameState.weaponDrops = this.gameState.weaponDrops.filter(
    drop => drop.id !== weaponDrop.id
  );
  
  this.updateAmmoDisplay();
  this.updateWeaponDisplay();
  document.getElementById('weapon-drop-indicator').style.display = 'none';
  this.showNotification(`Picked up ${weaponDrop.weapon.name}!`);
}

awardKillMoney(weaponType, victimTeam) {
  let reward = this.ECONOMY.KILL_REWARDS.rifle; // Default
  
  if (weaponType === 'pistol') reward = this.ECONOMY.KILL_REWARDS.pistol;
  else if (weaponType === 'rifle' && weaponType.includes('awp')) reward = this.ECONOMY.KILL_REWARDS.awp;
  else if (weaponType === 'knife') reward = this.ECONOMY.KILL_REWARDS.knife;
  
  this.addMoney(reward);
  this.showEconomyNotification(`Kill reward: +$${reward}`, 'success');
}

addMoney(amount) {
  this.localPlayer.money = Math.min(this.localPlayer.maxMoney, this.localPlayer.money + amount);
  this.updateMoneyDisplay();
}

updateMoneyDisplay() {
  const moneyElement = document.getElementById('money');
  if (moneyElement) {
    moneyElement.textContent = '$' + this.localPlayer.money;
  }
  
  const buyMenuMoney = document.getElementById('buy-menu-money');
  if (buyMenuMoney) {
    buyMenuMoney.textContent = '$' + this.localPlayer.money;
  }
}

updateAmmoDisplay() {
  const currentWeapon = this.getCurrentWeapon();
  if (currentWeapon && currentWeapon.ammo) {
    document.getElementById('ammo-clip').textContent = currentWeapon.ammo.clip;
    document.getElementById('ammo-reserve').textContent = currentWeapon.ammo.reserve;
  } else {
    document.getElementById('ammo-clip').textContent = '0';
    document.getElementById('ammo-reserve').textContent = '0';
  }
}

getRandomEnemyWeapon() {
  const possibleWeapons = ['ak47', 'm4a1', 'awp', 'famas', 'galil', 'deagle'];
  const weaponId = possibleWeapons[Math.floor(Math.random() * possibleWeapons.length)];
  const weaponData = this.ECONOMY.WEAPONS[weaponId];
  
  if (weaponData && weaponData.team && weaponData.team !== this.localPlayer.team) {
    return { ...weaponData };
  } else if (!weaponData.team) {
    return { ...weaponData };
  }
  
  // Fallback to basic weapons
  return { ...this.ECONOMY.WEAPONS['ak47'] };
}

showEconomyNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = 'economy-notification';
  
  if (type === 'error') {
    notification.style.color = '#ff4444';
    notification.style.borderLeftColor = '#ff4444';
  } else if (type === 'warning') {
    notification.style.color = '#ffaa00';
    notification.style.borderLeftColor = '#ffaa00';
  } else if (type === 'success') {
    notification.style.color = '#44ff44';
    notification.style.borderLeftColor = '#44ff44';
  }
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 3000);
}

gameLoop() {
  const deltaTime = 1/60; // 60 FPS
  
  // Update round timing
  this.updateRoundTiming(deltaTime);
  
  // Update bomb actions
  this.updateBombActions(deltaTime);
  
  // Update weapon system
  this.updateWeaponSystem();
  
  // 更新遊戲邏輯
  this.handleMovement();
  this.updateAimAngle();  // Update aim based on mouse
  this.updateAutoAim();
  this.updateAI();
  this.updateBullets();
  
  // Update visual effects
  this.updateVisualEffects();
  
  // Update UI elements
  this.updateKillFeedUI();
  
  // Check for weapon pickups
  this.checkWeaponPickup();
  
  // Check win conditions
  this.checkWinConditions();
  
  // 渲染
  this.render();
  
  requestAnimationFrame(() => this.gameLoop());
}

updateRoundTiming(deltaTime) {
  if (this.gameState.phase === 'ended') return;
  
  // Update phase timer
  if (this.gameState.phaseTimer > 0) {
    this.gameState.phaseTimer -= deltaTime;
    
    if (this.gameState.phaseTimer <= 0) {
      switch (this.gameState.phase) {
        case 'freeze':
          this.startBuyPhase();
          break;
        case 'buy':
          this.startPlayingPhase();
          break;
      }
    }
  }
  
  // Update round time during playing phase
  if (this.gameState.phase === 'playing') {
    this.gameState.roundTime -= deltaTime;
    const minutes = Math.floor(this.gameState.roundTime / 60);
    const seconds = Math.floor(this.gameState.roundTime % 60);
    document.getElementById('round-timer').textContent = minutes + ':' + seconds.toString().padStart(2, '0');
    
    // 更新炸彈時間
    if (this.gameState.bombPlanted) {
      this.gameState.bombTimer -= deltaTime;
      const bombMinutes = Math.floor(this.gameState.bombTimer / 60);
      const bombSeconds = Math.floor(this.gameState.bombTimer % 60);
      document.getElementById('bomb-timer').textContent = bombMinutes + ':' + bombSeconds.toString().padStart(2, '0');
      
      // Add ticking sound for last 10 seconds
      if (this.gameState.bombTimer <= 10 && this.gameState.bombTimer > 0) {
        const tickInterval = Math.floor(this.gameState.bombTimer);
        if (tickInterval !== this.lastTickSecond) {
          this.lastTickSecond = tickInterval;
          this.playTickSound();
        }
      }
      
      if (this.gameState.bombTimer <= 0) {
        this.explodeBomb();
      }
    }
  }
}

updateBombActions(deltaTime) {
  if (!this.gameState.bombAction || !this.localPlayer.alive) return;
  
  const elapsedTime = (Date.now() - this.gameState.bombActionStartTime) / 1000;
  
  if (this.gameState.bombAction === 'planting') {
    const progress = Math.min(elapsedTime / 3, 1); // 3 seconds to plant
    this.gameState.bombProgress = progress;
    
    // Update progress bar
    document.getElementById('bomb-progress-fill').style.width = (progress * 100) + '%';
    document.getElementById('bomb-progress-text').textContent = Math.floor(progress * 100) + '%';
    
    if (progress >= 1) {
      this.plantBomb(this.gameState.bombSite);
    }
  } else if (this.gameState.bombAction === 'defusing') {
    const defuseTime = this.localPlayer.hasDefuseKit ? 5 : 10;
    const progress = Math.min(elapsedTime / defuseTime, 1);
    this.gameState.bombProgress = progress;
    
    // Update progress bar
    document.getElementById('bomb-progress-fill').style.width = (progress * 100) + '%';
    document.getElementById('bomb-progress-text').textContent = Math.floor(progress * 100) + '%';
    
    if (progress >= 1) {
      this.defuseBomb();
    }
  }
}

checkWinConditions() {
  if (this.gameState.phase !== 'playing') return;
  
  // Check if time ran out
  if (this.gameState.roundTime <= 0) {
    if (this.gameState.bombPlanted) {
      // If bomb is planted, T wins if time runs out
      return; // Let bomb timer handle this
    } else {
      this.endRound('ct', 'time_up');
    }
  }
  
  // Check if all enemies are dead
  const aliveEnemies = this.enemies.filter(e => e.alive).length;
  if (aliveEnemies === 0 && this.localPlayer.alive) {
    const playerTeamWins = this.localPlayer.team;
    this.endRound(playerTeamWins, 'elimination');
  }
  
  // Check if player is dead and no teammates left
  if (!this.localPlayer.alive) {
    // In single player mode, if player dies, show spectator mode
    this.enterSpectatorMode();
  }
}

playTickSound() {
  // Simple tick sound - you could enhance this
  const audio = new Audio();
  audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjaO1fLNayIEJHrC7+OZURE=';
  audio.volume = 0.3;
  audio.play().catch(e => {});
}

explodeBomb() {
  this.gameState.bombPlanted = false;
  
  // Get bomb position from bomb site
  const bombSite = this.gameState.map.bombSites[this.gameState.bombSite];
  if (bombSite) {
    // Create massive explosion effect
    this.createExplosionEffect(bombSite.x, bombSite.y, 100);
    
    // Screen shake for explosion
    this.weaponSystem.screenShake = {
      x: (Math.random() - 0.5) * 20,
      y: (Math.random() - 0.5) * 20,
      intensity: 20,
      decay: 0.92
    };
  }
  
  this.showNotification('💣 Bomb exploded! Terrorists win!');
  document.getElementById('bomb-indicator').style.display = 'none';
  this.hideBombProgress();
  
  // Apply explosion damage
  this.applyExplosionDamage();
  
  this.endRound('t', 'bomb_exploded');
}

applyExplosionDamage() {
  if (!this.gameState.bombSite) return;
  
  const explosionRadius = 500;
  const maxDamage = 200;
  
  // Check damage to player
  const playerDist = Math.hypot(
    this.localPlayer.x - this.gameState.bombSite.x,
    this.localPlayer.y - this.gameState.bombSite.y
  );
  
  if (playerDist < explosionRadius && this.localPlayer.alive) {
    const damage = maxDamage * (1 - playerDist / explosionRadius);
    this.takeDamage(Math.floor(damage));
  }
  
  // Check damage to enemies
  this.enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    const enemyDist = Math.hypot(
      enemy.x - this.gameState.bombSite.x,
      enemy.y - this.gameState.bombSite.y
    );
    
    if (enemyDist < explosionRadius) {
      const damage = maxDamage * (1 - enemyDist / explosionRadius);
      enemy.health -= Math.floor(damage);
      if (enemy.health <= 0) {
        enemy.alive = false;
      }
    }
  });
}

enterSpectatorMode() {
  this.gameState.spectatorMode = 'free';
  this.gameState.spectatingPlayer = null;
  
  document.getElementById('death-screen').style.display = 'flex';
  document.getElementById('spectator-ui').style.display = 'block';
  document.getElementById('spectating-player').textContent = 'Free Look';
}
    }
    
    // 啟動遊戲
    let game;
    window.addEventListener('DOMContentLoaded', () => {
game = new CS16Game();
window.game = game; // Make game accessible globally for rebuy button
    });
  </script>
</body>
</html>
